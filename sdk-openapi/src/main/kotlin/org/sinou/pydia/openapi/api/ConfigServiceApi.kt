/**
 *
 * Please note:
 * This class is auto generated by OpenAPI Generator (https://openapi-generator.tech).
 * Do not edit this file manually.
 *
 */

@file:Suppress(
    "ArrayInDataClass",
    "EnumEntryName",
    "RemoveRedundantQualifierName",
    "UnusedImport"
)

package org.sinou.pydia.openapi.api

import java.io.IOException
import okhttp3.OkHttpClient
import okhttp3.HttpUrl

import org.sinou.pydia.openapi.model.ConfigurationMessageDataIsAnJsonRepresentationOfAnyValue
import org.sinou.pydia.openapi.model.CtlService
import org.sinou.pydia.openapi.model.DataSourceObjectDescription
import org.sinou.pydia.openapi.model.EncryptionAdminCreateKeyRequest
import org.sinou.pydia.openapi.model.EncryptionAdminCreateKeyResponse
import org.sinou.pydia.openapi.model.EncryptionAdminDeleteKeyRequest
import org.sinou.pydia.openapi.model.EncryptionAdminDeleteKeyResponse
import org.sinou.pydia.openapi.model.EncryptionAdminExportKeyRequest
import org.sinou.pydia.openapi.model.EncryptionAdminExportKeyResponse
import org.sinou.pydia.openapi.model.EncryptionAdminImportKeyRequest
import org.sinou.pydia.openapi.model.EncryptionAdminImportKeyResponse
import org.sinou.pydia.openapi.model.EncryptionAdminListKeysRequest
import org.sinou.pydia.openapi.model.EncryptionAdminListKeysResponse
import org.sinou.pydia.openapi.model.ObjectDataSource
import org.sinou.pydia.openapi.model.RegistryListRequest
import org.sinou.pydia.openapi.model.RegistryListResponse
import org.sinou.pydia.openapi.model.RestConfiguration
import org.sinou.pydia.openapi.model.RestControlServiceRequest
import org.sinou.pydia.openapi.model.RestCreatePeerFolderRequest
import org.sinou.pydia.openapi.model.RestCreatePeerFolderResponse
import org.sinou.pydia.openapi.model.RestCreateStorageBucketRequest
import org.sinou.pydia.openapi.model.RestCreateStorageBucketResponse
import org.sinou.pydia.openapi.model.RestDataSourceCollection
import org.sinou.pydia.openapi.model.RestDeleteDataSourceResponse
import org.sinou.pydia.openapi.model.RestDiscoveryResponse
import org.sinou.pydia.openapi.model.RestError
import org.sinou.pydia.openapi.model.RestListPeerFoldersRequest
import org.sinou.pydia.openapi.model.RestListPeersAddressesResponse
import org.sinou.pydia.openapi.model.RestListProcessesRequest
import org.sinou.pydia.openapi.model.RestListProcessesResponse
import org.sinou.pydia.openapi.model.RestListSitesResponse
import org.sinou.pydia.openapi.model.RestListStorageBucketsRequest
import org.sinou.pydia.openapi.model.RestNodesCollection
import org.sinou.pydia.openapi.model.RestOpenApiResponse
import org.sinou.pydia.openapi.model.RestSchedulerActionFormResponse
import org.sinou.pydia.openapi.model.RestSchedulerActionsResponse
import org.sinou.pydia.openapi.model.RestServiceCollection
import org.sinou.pydia.openapi.model.RestVersioningPolicyCollection
import org.sinou.pydia.openapi.model.TreeVersioningPolicy

import com.squareup.moshi.Json

import org.sinou.pydia.openapi.infrastructure.ApiClient
import org.sinou.pydia.openapi.infrastructure.ApiResponse
import org.sinou.pydia.openapi.infrastructure.ClientException
import org.sinou.pydia.openapi.infrastructure.ClientError
import org.sinou.pydia.openapi.infrastructure.ServerException
import org.sinou.pydia.openapi.infrastructure.ServerError
import org.sinou.pydia.openapi.infrastructure.MultiValueMap
import org.sinou.pydia.openapi.infrastructure.PartConfig
import org.sinou.pydia.openapi.infrastructure.RequestConfig
import org.sinou.pydia.openapi.infrastructure.RequestMethod
import org.sinou.pydia.openapi.infrastructure.ResponseType
import org.sinou.pydia.openapi.infrastructure.Success
import org.sinou.pydia.openapi.infrastructure.toMultiValue

class ConfigServiceApi(basePath: kotlin.String = defaultBasePath, client: OkHttpClient = ApiClient.defaultClient) : ApiClient(basePath, client) {
    companion object {
        @JvmStatic
        val defaultBasePath: String by lazy {
            System.getProperties().getProperty(ApiClient.baseUrlKey, "http://localhost")
        }
    }

    /**
     * Publish Forms definition for building screens in frontend
     * 
     * @param serviceName Retrieve a configuration form for a given service
     * @return RestDiscoveryResponse
     * @throws IllegalStateException If the request is not correctly configured
     * @throws IOException Rethrows the OkHttp execute method exception
     * @throws UnsupportedOperationException If the API returns an informational or redirection response
     * @throws ClientException If the API returns a client error response
     * @throws ServerException If the API returns a server error response
     */
    @Suppress("UNCHECKED_CAST")
    @Throws(IllegalStateException::class, IOException::class, UnsupportedOperationException::class, ClientException::class, ServerException::class)
    fun configFormsDiscovery(serviceName: kotlin.String) : RestDiscoveryResponse {
        val localVarResponse = configFormsDiscoveryWithHttpInfo(serviceName = serviceName)

        return when (localVarResponse.responseType) {
            ResponseType.Success -> (localVarResponse as Success<*>).data as RestDiscoveryResponse
            ResponseType.Informational -> throw UnsupportedOperationException("Client does not support Informational responses.")
            ResponseType.Redirection -> throw UnsupportedOperationException("Client does not support Redirection responses.")
            ResponseType.ClientError -> {
                val localVarError = localVarResponse as ClientError<*>
                throw ClientException("Client error : ${localVarError.statusCode} ${localVarError.message.orEmpty()}", localVarError.statusCode, localVarResponse)
            }
            ResponseType.ServerError -> {
                val localVarError = localVarResponse as ServerError<*>
                throw ServerException("Server error : ${localVarError.statusCode} ${localVarError.message.orEmpty()} ${localVarError.body}", localVarError.statusCode, localVarResponse)
            }
        }
    }

    /**
     * Publish Forms definition for building screens in frontend
     * 
     * @param serviceName Retrieve a configuration form for a given service
     * @return ApiResponse<RestDiscoveryResponse?>
     * @throws IllegalStateException If the request is not correctly configured
     * @throws IOException Rethrows the OkHttp execute method exception
     */
    @Suppress("UNCHECKED_CAST")
    @Throws(IllegalStateException::class, IOException::class)
    fun configFormsDiscoveryWithHttpInfo(serviceName: kotlin.String) : ApiResponse<RestDiscoveryResponse?> {
        val localVariableConfig = configFormsDiscoveryRequestConfig(serviceName = serviceName)

        return request<Unit, RestDiscoveryResponse>(
            localVariableConfig
        )
    }

    /**
     * To obtain the request config of the operation configFormsDiscovery
     *
     * @param serviceName Retrieve a configuration form for a given service
     * @return RequestConfig
     */
    fun configFormsDiscoveryRequestConfig(serviceName: kotlin.String) : RequestConfig<Unit> {
        val localVariableBody = null
        val localVariableQuery: MultiValueMap = mutableMapOf()
        val localVariableHeaders: MutableMap<String, String> = mutableMapOf()
        localVariableHeaders["Accept"] = "application/json"

        return RequestConfig(
            method = RequestMethod.GET,
            path = "/config/discovery/forms/{ServiceName}".replace("{"+"ServiceName"+"}", encodeURIComponent(serviceName.toString())),
            query = localVariableQuery,
            headers = localVariableHeaders,
            requiresAuthentication = false,
            body = localVariableBody
        )
    }

    /**
     * [Not Implemented]  Start/Stop a service
     * 
     * @param body 
     * @return CtlService
     * @throws IllegalStateException If the request is not correctly configured
     * @throws IOException Rethrows the OkHttp execute method exception
     * @throws UnsupportedOperationException If the API returns an informational or redirection response
     * @throws ClientException If the API returns a client error response
     * @throws ServerException If the API returns a server error response
     */
    @Suppress("UNCHECKED_CAST")
    @Throws(IllegalStateException::class, IOException::class, UnsupportedOperationException::class, ClientException::class, ServerException::class)
    fun controlService(body: RestControlServiceRequest) : CtlService {
        val localVarResponse = controlServiceWithHttpInfo(body = body)

        return when (localVarResponse.responseType) {
            ResponseType.Success -> (localVarResponse as Success<*>).data as CtlService
            ResponseType.Informational -> throw UnsupportedOperationException("Client does not support Informational responses.")
            ResponseType.Redirection -> throw UnsupportedOperationException("Client does not support Redirection responses.")
            ResponseType.ClientError -> {
                val localVarError = localVarResponse as ClientError<*>
                throw ClientException("Client error : ${localVarError.statusCode} ${localVarError.message.orEmpty()}", localVarError.statusCode, localVarResponse)
            }
            ResponseType.ServerError -> {
                val localVarError = localVarResponse as ServerError<*>
                throw ServerException("Server error : ${localVarError.statusCode} ${localVarError.message.orEmpty()} ${localVarError.body}", localVarError.statusCode, localVarResponse)
            }
        }
    }

    /**
     * [Not Implemented]  Start/Stop a service
     * 
     * @param body 
     * @return ApiResponse<CtlService?>
     * @throws IllegalStateException If the request is not correctly configured
     * @throws IOException Rethrows the OkHttp execute method exception
     */
    @Suppress("UNCHECKED_CAST")
    @Throws(IllegalStateException::class, IOException::class)
    fun controlServiceWithHttpInfo(body: RestControlServiceRequest) : ApiResponse<CtlService?> {
        val localVariableConfig = controlServiceRequestConfig(body = body)

        return request<RestControlServiceRequest, CtlService>(
            localVariableConfig
        )
    }

    /**
     * To obtain the request config of the operation controlService
     *
     * @param body 
     * @return RequestConfig
     */
    fun controlServiceRequestConfig(body: RestControlServiceRequest) : RequestConfig<RestControlServiceRequest> {
        val localVariableBody = body
        val localVariableQuery: MultiValueMap = mutableMapOf()
        val localVariableHeaders: MutableMap<String, String> = mutableMapOf()
        localVariableHeaders["Content-Type"] = "application/json"
        localVariableHeaders["Accept"] = "application/json"

        return RequestConfig(
            method = RequestMethod.POST,
            path = "/config/ctl",
            query = localVariableQuery,
            headers = localVariableHeaders,
            requiresAuthentication = false,
            body = localVariableBody
        )
    }

    /**
     * Create a new master key
     * 
     * @param body 
     * @return EncryptionAdminCreateKeyResponse
     * @throws IllegalStateException If the request is not correctly configured
     * @throws IOException Rethrows the OkHttp execute method exception
     * @throws UnsupportedOperationException If the API returns an informational or redirection response
     * @throws ClientException If the API returns a client error response
     * @throws ServerException If the API returns a server error response
     */
    @Suppress("UNCHECKED_CAST")
    @Throws(IllegalStateException::class, IOException::class, UnsupportedOperationException::class, ClientException::class, ServerException::class)
    fun createEncryptionKey(body: EncryptionAdminCreateKeyRequest) : EncryptionAdminCreateKeyResponse {
        val localVarResponse = createEncryptionKeyWithHttpInfo(body = body)

        return when (localVarResponse.responseType) {
            ResponseType.Success -> (localVarResponse as Success<*>).data as EncryptionAdminCreateKeyResponse
            ResponseType.Informational -> throw UnsupportedOperationException("Client does not support Informational responses.")
            ResponseType.Redirection -> throw UnsupportedOperationException("Client does not support Redirection responses.")
            ResponseType.ClientError -> {
                val localVarError = localVarResponse as ClientError<*>
                throw ClientException("Client error : ${localVarError.statusCode} ${localVarError.message.orEmpty()}", localVarError.statusCode, localVarResponse)
            }
            ResponseType.ServerError -> {
                val localVarError = localVarResponse as ServerError<*>
                throw ServerException("Server error : ${localVarError.statusCode} ${localVarError.message.orEmpty()} ${localVarError.body}", localVarError.statusCode, localVarResponse)
            }
        }
    }

    /**
     * Create a new master key
     * 
     * @param body 
     * @return ApiResponse<EncryptionAdminCreateKeyResponse?>
     * @throws IllegalStateException If the request is not correctly configured
     * @throws IOException Rethrows the OkHttp execute method exception
     */
    @Suppress("UNCHECKED_CAST")
    @Throws(IllegalStateException::class, IOException::class)
    fun createEncryptionKeyWithHttpInfo(body: EncryptionAdminCreateKeyRequest) : ApiResponse<EncryptionAdminCreateKeyResponse?> {
        val localVariableConfig = createEncryptionKeyRequestConfig(body = body)

        return request<EncryptionAdminCreateKeyRequest, EncryptionAdminCreateKeyResponse>(
            localVariableConfig
        )
    }

    /**
     * To obtain the request config of the operation createEncryptionKey
     *
     * @param body 
     * @return RequestConfig
     */
    fun createEncryptionKeyRequestConfig(body: EncryptionAdminCreateKeyRequest) : RequestConfig<EncryptionAdminCreateKeyRequest> {
        val localVariableBody = body
        val localVariableQuery: MultiValueMap = mutableMapOf()
        val localVariableHeaders: MutableMap<String, String> = mutableMapOf()
        localVariableHeaders["Content-Type"] = "application/json"
        localVariableHeaders["Accept"] = "application/json"

        return RequestConfig(
            method = RequestMethod.POST,
            path = "/config/encryption/create",
            query = localVariableQuery,
            headers = localVariableHeaders,
            requiresAuthentication = false,
            body = localVariableBody
        )
    }

    /**
     * Create a folder on a given path for a given peer (filesystem)
     * 
     * @param peerAddress Restrict listing to a given peer
     * @param body 
     * @return RestCreatePeerFolderResponse
     * @throws IllegalStateException If the request is not correctly configured
     * @throws IOException Rethrows the OkHttp execute method exception
     * @throws UnsupportedOperationException If the API returns an informational or redirection response
     * @throws ClientException If the API returns a client error response
     * @throws ServerException If the API returns a server error response
     */
    @Suppress("UNCHECKED_CAST")
    @Throws(IllegalStateException::class, IOException::class, UnsupportedOperationException::class, ClientException::class, ServerException::class)
    fun createPeerFolder(peerAddress: kotlin.String, body: RestCreatePeerFolderRequest) : RestCreatePeerFolderResponse {
        val localVarResponse = createPeerFolderWithHttpInfo(peerAddress = peerAddress, body = body)

        return when (localVarResponse.responseType) {
            ResponseType.Success -> (localVarResponse as Success<*>).data as RestCreatePeerFolderResponse
            ResponseType.Informational -> throw UnsupportedOperationException("Client does not support Informational responses.")
            ResponseType.Redirection -> throw UnsupportedOperationException("Client does not support Redirection responses.")
            ResponseType.ClientError -> {
                val localVarError = localVarResponse as ClientError<*>
                throw ClientException("Client error : ${localVarError.statusCode} ${localVarError.message.orEmpty()}", localVarError.statusCode, localVarResponse)
            }
            ResponseType.ServerError -> {
                val localVarError = localVarResponse as ServerError<*>
                throw ServerException("Server error : ${localVarError.statusCode} ${localVarError.message.orEmpty()} ${localVarError.body}", localVarError.statusCode, localVarResponse)
            }
        }
    }

    /**
     * Create a folder on a given path for a given peer (filesystem)
     * 
     * @param peerAddress Restrict listing to a given peer
     * @param body 
     * @return ApiResponse<RestCreatePeerFolderResponse?>
     * @throws IllegalStateException If the request is not correctly configured
     * @throws IOException Rethrows the OkHttp execute method exception
     */
    @Suppress("UNCHECKED_CAST")
    @Throws(IllegalStateException::class, IOException::class)
    fun createPeerFolderWithHttpInfo(peerAddress: kotlin.String, body: RestCreatePeerFolderRequest) : ApiResponse<RestCreatePeerFolderResponse?> {
        val localVariableConfig = createPeerFolderRequestConfig(peerAddress = peerAddress, body = body)

        return request<RestCreatePeerFolderRequest, RestCreatePeerFolderResponse>(
            localVariableConfig
        )
    }

    /**
     * To obtain the request config of the operation createPeerFolder
     *
     * @param peerAddress Restrict listing to a given peer
     * @param body 
     * @return RequestConfig
     */
    fun createPeerFolderRequestConfig(peerAddress: kotlin.String, body: RestCreatePeerFolderRequest) : RequestConfig<RestCreatePeerFolderRequest> {
        val localVariableBody = body
        val localVariableQuery: MultiValueMap = mutableMapOf()
        val localVariableHeaders: MutableMap<String, String> = mutableMapOf()
        localVariableHeaders["Content-Type"] = "application/json"
        localVariableHeaders["Accept"] = "application/json"

        return RequestConfig(
            method = RequestMethod.PUT,
            path = "/config/peers/{PeerAddress}".replace("{"+"PeerAddress"+"}", encodeURIComponent(peerAddress.toString())),
            query = localVariableQuery,
            headers = localVariableHeaders,
            requiresAuthentication = false,
            body = localVariableBody
        )
    }

    /**
     * List Buckets on a given object storage
     * 
     * @param bucketName 
     * @param body 
     * @return RestCreateStorageBucketResponse
     * @throws IllegalStateException If the request is not correctly configured
     * @throws IOException Rethrows the OkHttp execute method exception
     * @throws UnsupportedOperationException If the API returns an informational or redirection response
     * @throws ClientException If the API returns a client error response
     * @throws ServerException If the API returns a server error response
     */
    @Suppress("UNCHECKED_CAST")
    @Throws(IllegalStateException::class, IOException::class, UnsupportedOperationException::class, ClientException::class, ServerException::class)
    fun createStorageBucket(bucketName: kotlin.String, body: RestCreateStorageBucketRequest) : RestCreateStorageBucketResponse {
        val localVarResponse = createStorageBucketWithHttpInfo(bucketName = bucketName, body = body)

        return when (localVarResponse.responseType) {
            ResponseType.Success -> (localVarResponse as Success<*>).data as RestCreateStorageBucketResponse
            ResponseType.Informational -> throw UnsupportedOperationException("Client does not support Informational responses.")
            ResponseType.Redirection -> throw UnsupportedOperationException("Client does not support Redirection responses.")
            ResponseType.ClientError -> {
                val localVarError = localVarResponse as ClientError<*>
                throw ClientException("Client error : ${localVarError.statusCode} ${localVarError.message.orEmpty()}", localVarError.statusCode, localVarResponse)
            }
            ResponseType.ServerError -> {
                val localVarError = localVarResponse as ServerError<*>
                throw ServerException("Server error : ${localVarError.statusCode} ${localVarError.message.orEmpty()} ${localVarError.body}", localVarError.statusCode, localVarResponse)
            }
        }
    }

    /**
     * List Buckets on a given object storage
     * 
     * @param bucketName 
     * @param body 
     * @return ApiResponse<RestCreateStorageBucketResponse?>
     * @throws IllegalStateException If the request is not correctly configured
     * @throws IOException Rethrows the OkHttp execute method exception
     */
    @Suppress("UNCHECKED_CAST")
    @Throws(IllegalStateException::class, IOException::class)
    fun createStorageBucketWithHttpInfo(bucketName: kotlin.String, body: RestCreateStorageBucketRequest) : ApiResponse<RestCreateStorageBucketResponse?> {
        val localVariableConfig = createStorageBucketRequestConfig(bucketName = bucketName, body = body)

        return request<RestCreateStorageBucketRequest, RestCreateStorageBucketResponse>(
            localVariableConfig
        )
    }

    /**
     * To obtain the request config of the operation createStorageBucket
     *
     * @param bucketName 
     * @param body 
     * @return RequestConfig
     */
    fun createStorageBucketRequestConfig(bucketName: kotlin.String, body: RestCreateStorageBucketRequest) : RequestConfig<RestCreateStorageBucketRequest> {
        val localVariableBody = body
        val localVariableQuery: MultiValueMap = mutableMapOf()
        val localVariableHeaders: MutableMap<String, String> = mutableMapOf()
        localVariableHeaders["Content-Type"] = "application/json"
        localVariableHeaders["Accept"] = "application/json"

        return RequestConfig(
            method = RequestMethod.PUT,
            path = "/config/buckets/{BucketName}".replace("{"+"BucketName"+"}", encodeURIComponent(bucketName.toString())),
            query = localVariableQuery,
            headers = localVariableHeaders,
            requiresAuthentication = false,
            body = localVariableBody
        )
    }

    /**
     * enum for parameter storageType
     */
     enum class StorageTypeDeleteDataSource(val value: kotlin.String) {
         @Json(name = "LOCAL") LOCAL("LOCAL"),
         @Json(name = "S3") S3("S3"),
         @Json(name = "SMB") SMB("SMB"),
         @Json(name = "CELLS") CELLS("CELLS"),
         @Json(name = "AZURE") AZURE("AZURE"),
         @Json(name = "GCS") GCS("GCS"),
         @Json(name = "B2") B2("B2"),
         @Json(name = "MANTA") MANTA("MANTA"),
         @Json(name = "SIA") SIA("SIA")
     }

    /**
     * enum for parameter encryptionMode
     */
     enum class EncryptionModeDeleteDataSource(val value: kotlin.String) {
         @Json(name = "CLEAR") CLEAR("CLEAR"),
         @Json(name = "MASTER") MASTER("MASTER"),
         @Json(name = "USER") USER("USER"),
         @Json(name = "USER_PWD") USER_PWD("USER_PWD")
     }

    /**
     * Delete a datasource
     * 
     * @param name Name of the data source (max length 34)
     * @param disabled Whether this data source is disabled or running (optional)
     * @param storageType Type of underlying storage (LOCAL, S3, AZURE, GCS) (optional, default to LOCAL)
     * @param objectsServiceName Corresponding objects service name (underlying s3 service) (optional)
     * @param objectsHost Corresponding objects service host (optional)
     * @param objectsPort Corresponding objects service port (optional)
     * @param objectsSecure Corresponding objects service connection type (optional)
     * @param objectsBucket Corresponding objects service bucket (optional)
     * @param objectsBaseFolder Corresponding objects service base folder inside the bucket (optional)
     * @param apiKey Corresponding objects service api key (optional)
     * @param apiSecret Corresponding objects service api secret (optional)
     * @param peerAddress Peer address of the data source (optional)
     * @param watch Not implemented, whether to watch for underlying changes on the FS (optional)
     * @param flatStorage Store data in flat format (object-storage like) (optional)
     * @param skipSyncOnRestart Do not trigger resync at start (optional)
     * @param encryptionMode Type of encryption applied before sending data to storage (optional, default to CLEAR)
     * @param encryptionKey Encryption key used for encrypting data (optional)
     * @param versioningPolicyName Versioning policy describes how files are kept in the versioning queue (optional)
     * @param creationDate Data Source creation date (optional)
     * @param lastSynchronizationDate Data Source last synchronization date (optional)
     * @return RestDeleteDataSourceResponse
     * @throws IllegalStateException If the request is not correctly configured
     * @throws IOException Rethrows the OkHttp execute method exception
     * @throws UnsupportedOperationException If the API returns an informational or redirection response
     * @throws ClientException If the API returns a client error response
     * @throws ServerException If the API returns a server error response
     */
    @Suppress("UNCHECKED_CAST")
    @Throws(IllegalStateException::class, IOException::class, UnsupportedOperationException::class, ClientException::class, ServerException::class)
    fun deleteDataSource(name: kotlin.String, disabled: kotlin.Boolean? = null, storageType: StorageTypeDeleteDataSource? = StorageTypeDeleteDataSource.LOCAL, objectsServiceName: kotlin.String? = null, objectsHost: kotlin.String? = null, objectsPort: kotlin.Int? = null, objectsSecure: kotlin.Boolean? = null, objectsBucket: kotlin.String? = null, objectsBaseFolder: kotlin.String? = null, apiKey: kotlin.String? = null, apiSecret: kotlin.String? = null, peerAddress: kotlin.String? = null, watch: kotlin.Boolean? = null, flatStorage: kotlin.Boolean? = null, skipSyncOnRestart: kotlin.Boolean? = null, encryptionMode: EncryptionModeDeleteDataSource? = EncryptionModeDeleteDataSource.CLEAR, encryptionKey: kotlin.String? = null, versioningPolicyName: kotlin.String? = null, creationDate: kotlin.Int? = null, lastSynchronizationDate: kotlin.Int? = null) : RestDeleteDataSourceResponse {
        val localVarResponse = deleteDataSourceWithHttpInfo(name = name, disabled = disabled, storageType = storageType, objectsServiceName = objectsServiceName, objectsHost = objectsHost, objectsPort = objectsPort, objectsSecure = objectsSecure, objectsBucket = objectsBucket, objectsBaseFolder = objectsBaseFolder, apiKey = apiKey, apiSecret = apiSecret, peerAddress = peerAddress, watch = watch, flatStorage = flatStorage, skipSyncOnRestart = skipSyncOnRestart, encryptionMode = encryptionMode, encryptionKey = encryptionKey, versioningPolicyName = versioningPolicyName, creationDate = creationDate, lastSynchronizationDate = lastSynchronizationDate)

        return when (localVarResponse.responseType) {
            ResponseType.Success -> (localVarResponse as Success<*>).data as RestDeleteDataSourceResponse
            ResponseType.Informational -> throw UnsupportedOperationException("Client does not support Informational responses.")
            ResponseType.Redirection -> throw UnsupportedOperationException("Client does not support Redirection responses.")
            ResponseType.ClientError -> {
                val localVarError = localVarResponse as ClientError<*>
                throw ClientException("Client error : ${localVarError.statusCode} ${localVarError.message.orEmpty()}", localVarError.statusCode, localVarResponse)
            }
            ResponseType.ServerError -> {
                val localVarError = localVarResponse as ServerError<*>
                throw ServerException("Server error : ${localVarError.statusCode} ${localVarError.message.orEmpty()} ${localVarError.body}", localVarError.statusCode, localVarResponse)
            }
        }
    }

    /**
     * Delete a datasource
     * 
     * @param name Name of the data source (max length 34)
     * @param disabled Whether this data source is disabled or running (optional)
     * @param storageType Type of underlying storage (LOCAL, S3, AZURE, GCS) (optional, default to LOCAL)
     * @param objectsServiceName Corresponding objects service name (underlying s3 service) (optional)
     * @param objectsHost Corresponding objects service host (optional)
     * @param objectsPort Corresponding objects service port (optional)
     * @param objectsSecure Corresponding objects service connection type (optional)
     * @param objectsBucket Corresponding objects service bucket (optional)
     * @param objectsBaseFolder Corresponding objects service base folder inside the bucket (optional)
     * @param apiKey Corresponding objects service api key (optional)
     * @param apiSecret Corresponding objects service api secret (optional)
     * @param peerAddress Peer address of the data source (optional)
     * @param watch Not implemented, whether to watch for underlying changes on the FS (optional)
     * @param flatStorage Store data in flat format (object-storage like) (optional)
     * @param skipSyncOnRestart Do not trigger resync at start (optional)
     * @param encryptionMode Type of encryption applied before sending data to storage (optional, default to CLEAR)
     * @param encryptionKey Encryption key used for encrypting data (optional)
     * @param versioningPolicyName Versioning policy describes how files are kept in the versioning queue (optional)
     * @param creationDate Data Source creation date (optional)
     * @param lastSynchronizationDate Data Source last synchronization date (optional)
     * @return ApiResponse<RestDeleteDataSourceResponse?>
     * @throws IllegalStateException If the request is not correctly configured
     * @throws IOException Rethrows the OkHttp execute method exception
     */
    @Suppress("UNCHECKED_CAST")
    @Throws(IllegalStateException::class, IOException::class)
    fun deleteDataSourceWithHttpInfo(name: kotlin.String, disabled: kotlin.Boolean?, storageType: StorageTypeDeleteDataSource?, objectsServiceName: kotlin.String?, objectsHost: kotlin.String?, objectsPort: kotlin.Int?, objectsSecure: kotlin.Boolean?, objectsBucket: kotlin.String?, objectsBaseFolder: kotlin.String?, apiKey: kotlin.String?, apiSecret: kotlin.String?, peerAddress: kotlin.String?, watch: kotlin.Boolean?, flatStorage: kotlin.Boolean?, skipSyncOnRestart: kotlin.Boolean?, encryptionMode: EncryptionModeDeleteDataSource?, encryptionKey: kotlin.String?, versioningPolicyName: kotlin.String?, creationDate: kotlin.Int?, lastSynchronizationDate: kotlin.Int?) : ApiResponse<RestDeleteDataSourceResponse?> {
        val localVariableConfig = deleteDataSourceRequestConfig(name = name, disabled = disabled, storageType = storageType, objectsServiceName = objectsServiceName, objectsHost = objectsHost, objectsPort = objectsPort, objectsSecure = objectsSecure, objectsBucket = objectsBucket, objectsBaseFolder = objectsBaseFolder, apiKey = apiKey, apiSecret = apiSecret, peerAddress = peerAddress, watch = watch, flatStorage = flatStorage, skipSyncOnRestart = skipSyncOnRestart, encryptionMode = encryptionMode, encryptionKey = encryptionKey, versioningPolicyName = versioningPolicyName, creationDate = creationDate, lastSynchronizationDate = lastSynchronizationDate)

        return request<Unit, RestDeleteDataSourceResponse>(
            localVariableConfig
        )
    }

    /**
     * To obtain the request config of the operation deleteDataSource
     *
     * @param name Name of the data source (max length 34)
     * @param disabled Whether this data source is disabled or running (optional)
     * @param storageType Type of underlying storage (LOCAL, S3, AZURE, GCS) (optional, default to LOCAL)
     * @param objectsServiceName Corresponding objects service name (underlying s3 service) (optional)
     * @param objectsHost Corresponding objects service host (optional)
     * @param objectsPort Corresponding objects service port (optional)
     * @param objectsSecure Corresponding objects service connection type (optional)
     * @param objectsBucket Corresponding objects service bucket (optional)
     * @param objectsBaseFolder Corresponding objects service base folder inside the bucket (optional)
     * @param apiKey Corresponding objects service api key (optional)
     * @param apiSecret Corresponding objects service api secret (optional)
     * @param peerAddress Peer address of the data source (optional)
     * @param watch Not implemented, whether to watch for underlying changes on the FS (optional)
     * @param flatStorage Store data in flat format (object-storage like) (optional)
     * @param skipSyncOnRestart Do not trigger resync at start (optional)
     * @param encryptionMode Type of encryption applied before sending data to storage (optional, default to CLEAR)
     * @param encryptionKey Encryption key used for encrypting data (optional)
     * @param versioningPolicyName Versioning policy describes how files are kept in the versioning queue (optional)
     * @param creationDate Data Source creation date (optional)
     * @param lastSynchronizationDate Data Source last synchronization date (optional)
     * @return RequestConfig
     */
    fun deleteDataSourceRequestConfig(name: kotlin.String, disabled: kotlin.Boolean?, storageType: StorageTypeDeleteDataSource?, objectsServiceName: kotlin.String?, objectsHost: kotlin.String?, objectsPort: kotlin.Int?, objectsSecure: kotlin.Boolean?, objectsBucket: kotlin.String?, objectsBaseFolder: kotlin.String?, apiKey: kotlin.String?, apiSecret: kotlin.String?, peerAddress: kotlin.String?, watch: kotlin.Boolean?, flatStorage: kotlin.Boolean?, skipSyncOnRestart: kotlin.Boolean?, encryptionMode: EncryptionModeDeleteDataSource?, encryptionKey: kotlin.String?, versioningPolicyName: kotlin.String?, creationDate: kotlin.Int?, lastSynchronizationDate: kotlin.Int?) : RequestConfig<Unit> {
        val localVariableBody = null
        val localVariableQuery: MultiValueMap = mutableMapOf<kotlin.String, kotlin.collections.List<kotlin.String>>()
            .apply {
                if (disabled != null) {
                    put("Disabled", listOf(disabled.toString()))
                }
                if (storageType != null) {
                    put("StorageType", listOf(storageType.value))
                }
                if (objectsServiceName != null) {
                    put("ObjectsServiceName", listOf(objectsServiceName.toString()))
                }
                if (objectsHost != null) {
                    put("ObjectsHost", listOf(objectsHost.toString()))
                }
                if (objectsPort != null) {
                    put("ObjectsPort", listOf(objectsPort.toString()))
                }
                if (objectsSecure != null) {
                    put("ObjectsSecure", listOf(objectsSecure.toString()))
                }
                if (objectsBucket != null) {
                    put("ObjectsBucket", listOf(objectsBucket.toString()))
                }
                if (objectsBaseFolder != null) {
                    put("ObjectsBaseFolder", listOf(objectsBaseFolder.toString()))
                }
                if (apiKey != null) {
                    put("ApiKey", listOf(apiKey.toString()))
                }
                if (apiSecret != null) {
                    put("ApiSecret", listOf(apiSecret.toString()))
                }
                if (peerAddress != null) {
                    put("PeerAddress", listOf(peerAddress.toString()))
                }
                if (watch != null) {
                    put("Watch", listOf(watch.toString()))
                }
                if (flatStorage != null) {
                    put("FlatStorage", listOf(flatStorage.toString()))
                }
                if (skipSyncOnRestart != null) {
                    put("SkipSyncOnRestart", listOf(skipSyncOnRestart.toString()))
                }
                if (encryptionMode != null) {
                    put("EncryptionMode", listOf(encryptionMode.value))
                }
                if (encryptionKey != null) {
                    put("EncryptionKey", listOf(encryptionKey.toString()))
                }
                if (versioningPolicyName != null) {
                    put("VersioningPolicyName", listOf(versioningPolicyName.toString()))
                }
                if (creationDate != null) {
                    put("CreationDate", listOf(creationDate.toString()))
                }
                if (lastSynchronizationDate != null) {
                    put("LastSynchronizationDate", listOf(lastSynchronizationDate.toString()))
                }
            }
        val localVariableHeaders: MutableMap<String, String> = mutableMapOf()
        localVariableHeaders["Accept"] = "application/json"

        return RequestConfig(
            method = RequestMethod.DELETE,
            path = "/config/datasource/{Name}".replace("{"+"Name"+"}", encodeURIComponent(name.toString())),
            query = localVariableQuery,
            headers = localVariableHeaders,
            requiresAuthentication = false,
            body = localVariableBody
        )
    }

    /**
     * Delete an existing master key
     * 
     * @param body 
     * @return EncryptionAdminDeleteKeyResponse
     * @throws IllegalStateException If the request is not correctly configured
     * @throws IOException Rethrows the OkHttp execute method exception
     * @throws UnsupportedOperationException If the API returns an informational or redirection response
     * @throws ClientException If the API returns a client error response
     * @throws ServerException If the API returns a server error response
     */
    @Suppress("UNCHECKED_CAST")
    @Throws(IllegalStateException::class, IOException::class, UnsupportedOperationException::class, ClientException::class, ServerException::class)
    fun deleteEncryptionKey(body: EncryptionAdminDeleteKeyRequest) : EncryptionAdminDeleteKeyResponse {
        val localVarResponse = deleteEncryptionKeyWithHttpInfo(body = body)

        return when (localVarResponse.responseType) {
            ResponseType.Success -> (localVarResponse as Success<*>).data as EncryptionAdminDeleteKeyResponse
            ResponseType.Informational -> throw UnsupportedOperationException("Client does not support Informational responses.")
            ResponseType.Redirection -> throw UnsupportedOperationException("Client does not support Redirection responses.")
            ResponseType.ClientError -> {
                val localVarError = localVarResponse as ClientError<*>
                throw ClientException("Client error : ${localVarError.statusCode} ${localVarError.message.orEmpty()}", localVarError.statusCode, localVarResponse)
            }
            ResponseType.ServerError -> {
                val localVarError = localVarResponse as ServerError<*>
                throw ServerException("Server error : ${localVarError.statusCode} ${localVarError.message.orEmpty()} ${localVarError.body}", localVarError.statusCode, localVarResponse)
            }
        }
    }

    /**
     * Delete an existing master key
     * 
     * @param body 
     * @return ApiResponse<EncryptionAdminDeleteKeyResponse?>
     * @throws IllegalStateException If the request is not correctly configured
     * @throws IOException Rethrows the OkHttp execute method exception
     */
    @Suppress("UNCHECKED_CAST")
    @Throws(IllegalStateException::class, IOException::class)
    fun deleteEncryptionKeyWithHttpInfo(body: EncryptionAdminDeleteKeyRequest) : ApiResponse<EncryptionAdminDeleteKeyResponse?> {
        val localVariableConfig = deleteEncryptionKeyRequestConfig(body = body)

        return request<EncryptionAdminDeleteKeyRequest, EncryptionAdminDeleteKeyResponse>(
            localVariableConfig
        )
    }

    /**
     * To obtain the request config of the operation deleteEncryptionKey
     *
     * @param body 
     * @return RequestConfig
     */
    fun deleteEncryptionKeyRequestConfig(body: EncryptionAdminDeleteKeyRequest) : RequestConfig<EncryptionAdminDeleteKeyRequest> {
        val localVariableBody = body
        val localVariableQuery: MultiValueMap = mutableMapOf()
        val localVariableHeaders: MutableMap<String, String> = mutableMapOf()
        localVariableHeaders["Content-Type"] = "application/json"
        localVariableHeaders["Accept"] = "application/json"

        return RequestConfig(
            method = RequestMethod.POST,
            path = "/config/encryption/delete",
            query = localVariableQuery,
            headers = localVariableHeaders,
            requiresAuthentication = false,
            body = localVariableBody
        )
    }

    /**
     * Publish available endpoints
     * 
     * @param endpointType Filter result to a specific endpoint type (optional)
     * @return RestDiscoveryResponse
     * @throws IllegalStateException If the request is not correctly configured
     * @throws IOException Rethrows the OkHttp execute method exception
     * @throws UnsupportedOperationException If the API returns an informational or redirection response
     * @throws ClientException If the API returns a client error response
     * @throws ServerException If the API returns a server error response
     */
    @Suppress("UNCHECKED_CAST")
    @Throws(IllegalStateException::class, IOException::class, UnsupportedOperationException::class, ClientException::class, ServerException::class)
    fun endpointsDiscovery(endpointType: kotlin.String? = null) : RestDiscoveryResponse {
        val localVarResponse = endpointsDiscoveryWithHttpInfo(endpointType = endpointType)

        return when (localVarResponse.responseType) {
            ResponseType.Success -> (localVarResponse as Success<*>).data as RestDiscoveryResponse
            ResponseType.Informational -> throw UnsupportedOperationException("Client does not support Informational responses.")
            ResponseType.Redirection -> throw UnsupportedOperationException("Client does not support Redirection responses.")
            ResponseType.ClientError -> {
                val localVarError = localVarResponse as ClientError<*>
                throw ClientException("Client error : ${localVarError.statusCode} ${localVarError.message.orEmpty()}", localVarError.statusCode, localVarResponse)
            }
            ResponseType.ServerError -> {
                val localVarError = localVarResponse as ServerError<*>
                throw ServerException("Server error : ${localVarError.statusCode} ${localVarError.message.orEmpty()} ${localVarError.body}", localVarError.statusCode, localVarResponse)
            }
        }
    }

    /**
     * Publish available endpoints
     * 
     * @param endpointType Filter result to a specific endpoint type (optional)
     * @return ApiResponse<RestDiscoveryResponse?>
     * @throws IllegalStateException If the request is not correctly configured
     * @throws IOException Rethrows the OkHttp execute method exception
     */
    @Suppress("UNCHECKED_CAST")
    @Throws(IllegalStateException::class, IOException::class)
    fun endpointsDiscoveryWithHttpInfo(endpointType: kotlin.String?) : ApiResponse<RestDiscoveryResponse?> {
        val localVariableConfig = endpointsDiscoveryRequestConfig(endpointType = endpointType)

        return request<Unit, RestDiscoveryResponse>(
            localVariableConfig
        )
    }

    /**
     * To obtain the request config of the operation endpointsDiscovery
     *
     * @param endpointType Filter result to a specific endpoint type (optional)
     * @return RequestConfig
     */
    fun endpointsDiscoveryRequestConfig(endpointType: kotlin.String?) : RequestConfig<Unit> {
        val localVariableBody = null
        val localVariableQuery: MultiValueMap = mutableMapOf<kotlin.String, kotlin.collections.List<kotlin.String>>()
            .apply {
                if (endpointType != null) {
                    put("EndpointType", listOf(endpointType.toString()))
                }
            }
        val localVariableHeaders: MutableMap<String, String> = mutableMapOf()
        localVariableHeaders["Accept"] = "application/json"

        return RequestConfig(
            method = RequestMethod.GET,
            path = "/config/discovery",
            query = localVariableQuery,
            headers = localVariableHeaders,
            requiresAuthentication = false,
            body = localVariableBody
        )
    }

    /**
     * Export a master key for backup purpose, protected with a password
     * 
     * @param body 
     * @return EncryptionAdminExportKeyResponse
     * @throws IllegalStateException If the request is not correctly configured
     * @throws IOException Rethrows the OkHttp execute method exception
     * @throws UnsupportedOperationException If the API returns an informational or redirection response
     * @throws ClientException If the API returns a client error response
     * @throws ServerException If the API returns a server error response
     */
    @Suppress("UNCHECKED_CAST")
    @Throws(IllegalStateException::class, IOException::class, UnsupportedOperationException::class, ClientException::class, ServerException::class)
    fun exportEncryptionKey(body: EncryptionAdminExportKeyRequest) : EncryptionAdminExportKeyResponse {
        val localVarResponse = exportEncryptionKeyWithHttpInfo(body = body)

        return when (localVarResponse.responseType) {
            ResponseType.Success -> (localVarResponse as Success<*>).data as EncryptionAdminExportKeyResponse
            ResponseType.Informational -> throw UnsupportedOperationException("Client does not support Informational responses.")
            ResponseType.Redirection -> throw UnsupportedOperationException("Client does not support Redirection responses.")
            ResponseType.ClientError -> {
                val localVarError = localVarResponse as ClientError<*>
                throw ClientException("Client error : ${localVarError.statusCode} ${localVarError.message.orEmpty()}", localVarError.statusCode, localVarResponse)
            }
            ResponseType.ServerError -> {
                val localVarError = localVarResponse as ServerError<*>
                throw ServerException("Server error : ${localVarError.statusCode} ${localVarError.message.orEmpty()} ${localVarError.body}", localVarError.statusCode, localVarResponse)
            }
        }
    }

    /**
     * Export a master key for backup purpose, protected with a password
     * 
     * @param body 
     * @return ApiResponse<EncryptionAdminExportKeyResponse?>
     * @throws IllegalStateException If the request is not correctly configured
     * @throws IOException Rethrows the OkHttp execute method exception
     */
    @Suppress("UNCHECKED_CAST")
    @Throws(IllegalStateException::class, IOException::class)
    fun exportEncryptionKeyWithHttpInfo(body: EncryptionAdminExportKeyRequest) : ApiResponse<EncryptionAdminExportKeyResponse?> {
        val localVariableConfig = exportEncryptionKeyRequestConfig(body = body)

        return request<EncryptionAdminExportKeyRequest, EncryptionAdminExportKeyResponse>(
            localVariableConfig
        )
    }

    /**
     * To obtain the request config of the operation exportEncryptionKey
     *
     * @param body 
     * @return RequestConfig
     */
    fun exportEncryptionKeyRequestConfig(body: EncryptionAdminExportKeyRequest) : RequestConfig<EncryptionAdminExportKeyRequest> {
        val localVariableBody = body
        val localVariableQuery: MultiValueMap = mutableMapOf()
        val localVariableHeaders: MutableMap<String, String> = mutableMapOf()
        localVariableHeaders["Content-Type"] = "application/json"
        localVariableHeaders["Accept"] = "application/json"

        return RequestConfig(
            method = RequestMethod.POST,
            path = "/config/encryption/export",
            query = localVariableQuery,
            headers = localVariableHeaders,
            requiresAuthentication = false,
            body = localVariableBody
        )
    }

    /**
     * Generic config Get using a full path in the config tree
     * 
     * @param fullPath Full slash-separated path to the config key
     * @param `data` JSON-encoded data to store (optional)
     * @return RestConfiguration
     * @throws IllegalStateException If the request is not correctly configured
     * @throws IOException Rethrows the OkHttp execute method exception
     * @throws UnsupportedOperationException If the API returns an informational or redirection response
     * @throws ClientException If the API returns a client error response
     * @throws ServerException If the API returns a server error response
     */
    @Suppress("UNCHECKED_CAST")
    @Throws(IllegalStateException::class, IOException::class, UnsupportedOperationException::class, ClientException::class, ServerException::class)
    fun getConfig(fullPath: kotlin.String, `data`: kotlin.String? = null) : RestConfiguration {
        val localVarResponse = getConfigWithHttpInfo(fullPath = fullPath, `data` = `data`)

        return when (localVarResponse.responseType) {
            ResponseType.Success -> (localVarResponse as Success<*>).data as RestConfiguration
            ResponseType.Informational -> throw UnsupportedOperationException("Client does not support Informational responses.")
            ResponseType.Redirection -> throw UnsupportedOperationException("Client does not support Redirection responses.")
            ResponseType.ClientError -> {
                val localVarError = localVarResponse as ClientError<*>
                throw ClientException("Client error : ${localVarError.statusCode} ${localVarError.message.orEmpty()}", localVarError.statusCode, localVarResponse)
            }
            ResponseType.ServerError -> {
                val localVarError = localVarResponse as ServerError<*>
                throw ServerException("Server error : ${localVarError.statusCode} ${localVarError.message.orEmpty()} ${localVarError.body}", localVarError.statusCode, localVarResponse)
            }
        }
    }

    /**
     * Generic config Get using a full path in the config tree
     * 
     * @param fullPath Full slash-separated path to the config key
     * @param `data` JSON-encoded data to store (optional)
     * @return ApiResponse<RestConfiguration?>
     * @throws IllegalStateException If the request is not correctly configured
     * @throws IOException Rethrows the OkHttp execute method exception
     */
    @Suppress("UNCHECKED_CAST")
    @Throws(IllegalStateException::class, IOException::class)
    fun getConfigWithHttpInfo(fullPath: kotlin.String, `data`: kotlin.String?) : ApiResponse<RestConfiguration?> {
        val localVariableConfig = getConfigRequestConfig(fullPath = fullPath, `data` = `data`)

        return request<Unit, RestConfiguration>(
            localVariableConfig
        )
    }

    /**
     * To obtain the request config of the operation getConfig
     *
     * @param fullPath Full slash-separated path to the config key
     * @param `data` JSON-encoded data to store (optional)
     * @return RequestConfig
     */
    fun getConfigRequestConfig(fullPath: kotlin.String, `data`: kotlin.String?) : RequestConfig<Unit> {
        val localVariableBody = null
        val localVariableQuery: MultiValueMap = mutableMapOf<kotlin.String, kotlin.collections.List<kotlin.String>>()
            .apply {
                if (`data` != null) {
                    put("Data", listOf(`data`.toString()))
                }
            }
        val localVariableHeaders: MutableMap<String, String> = mutableMapOf()
        localVariableHeaders["Accept"] = "application/json"

        return RequestConfig(
            method = RequestMethod.GET,
            path = "/config/{FullPath}".replace("{"+"FullPath"+"}", encodeURIComponent(fullPath.toString())),
            query = localVariableQuery,
            headers = localVariableHeaders,
            requiresAuthentication = false,
            body = localVariableBody
        )
    }

    /**
     * enum for parameter storageType
     */
     enum class StorageTypeGetDataSource(val value: kotlin.String) {
         @Json(name = "LOCAL") LOCAL("LOCAL"),
         @Json(name = "S3") S3("S3"),
         @Json(name = "SMB") SMB("SMB"),
         @Json(name = "CELLS") CELLS("CELLS"),
         @Json(name = "AZURE") AZURE("AZURE"),
         @Json(name = "GCS") GCS("GCS"),
         @Json(name = "B2") B2("B2"),
         @Json(name = "MANTA") MANTA("MANTA"),
         @Json(name = "SIA") SIA("SIA")
     }

    /**
     * enum for parameter encryptionMode
     */
     enum class EncryptionModeGetDataSource(val value: kotlin.String) {
         @Json(name = "CLEAR") CLEAR("CLEAR"),
         @Json(name = "MASTER") MASTER("MASTER"),
         @Json(name = "USER") USER("USER"),
         @Json(name = "USER_PWD") USER_PWD("USER_PWD")
     }

    /**
     * Load datasource information
     * 
     * @param name Name of the data source (max length 34)
     * @param disabled Whether this data source is disabled or running (optional)
     * @param storageType Type of underlying storage (LOCAL, S3, AZURE, GCS) (optional, default to LOCAL)
     * @param objectsServiceName Corresponding objects service name (underlying s3 service) (optional)
     * @param objectsHost Corresponding objects service host (optional)
     * @param objectsPort Corresponding objects service port (optional)
     * @param objectsSecure Corresponding objects service connection type (optional)
     * @param objectsBucket Corresponding objects service bucket (optional)
     * @param objectsBaseFolder Corresponding objects service base folder inside the bucket (optional)
     * @param apiKey Corresponding objects service api key (optional)
     * @param apiSecret Corresponding objects service api secret (optional)
     * @param peerAddress Peer address of the data source (optional)
     * @param watch Not implemented, whether to watch for underlying changes on the FS (optional)
     * @param flatStorage Store data in flat format (object-storage like) (optional)
     * @param skipSyncOnRestart Do not trigger resync at start (optional)
     * @param encryptionMode Type of encryption applied before sending data to storage (optional, default to CLEAR)
     * @param encryptionKey Encryption key used for encrypting data (optional)
     * @param versioningPolicyName Versioning policy describes how files are kept in the versioning queue (optional)
     * @param creationDate Data Source creation date (optional)
     * @param lastSynchronizationDate Data Source last synchronization date (optional)
     * @return ObjectDataSource
     * @throws IllegalStateException If the request is not correctly configured
     * @throws IOException Rethrows the OkHttp execute method exception
     * @throws UnsupportedOperationException If the API returns an informational or redirection response
     * @throws ClientException If the API returns a client error response
     * @throws ServerException If the API returns a server error response
     */
    @Suppress("UNCHECKED_CAST")
    @Throws(IllegalStateException::class, IOException::class, UnsupportedOperationException::class, ClientException::class, ServerException::class)
    fun getDataSource(name: kotlin.String, disabled: kotlin.Boolean? = null, storageType: StorageTypeGetDataSource? = StorageTypeGetDataSource.LOCAL, objectsServiceName: kotlin.String? = null, objectsHost: kotlin.String? = null, objectsPort: kotlin.Int? = null, objectsSecure: kotlin.Boolean? = null, objectsBucket: kotlin.String? = null, objectsBaseFolder: kotlin.String? = null, apiKey: kotlin.String? = null, apiSecret: kotlin.String? = null, peerAddress: kotlin.String? = null, watch: kotlin.Boolean? = null, flatStorage: kotlin.Boolean? = null, skipSyncOnRestart: kotlin.Boolean? = null, encryptionMode: EncryptionModeGetDataSource? = EncryptionModeGetDataSource.CLEAR, encryptionKey: kotlin.String? = null, versioningPolicyName: kotlin.String? = null, creationDate: kotlin.Int? = null, lastSynchronizationDate: kotlin.Int? = null) : ObjectDataSource {
        val localVarResponse = getDataSourceWithHttpInfo(name = name, disabled = disabled, storageType = storageType, objectsServiceName = objectsServiceName, objectsHost = objectsHost, objectsPort = objectsPort, objectsSecure = objectsSecure, objectsBucket = objectsBucket, objectsBaseFolder = objectsBaseFolder, apiKey = apiKey, apiSecret = apiSecret, peerAddress = peerAddress, watch = watch, flatStorage = flatStorage, skipSyncOnRestart = skipSyncOnRestart, encryptionMode = encryptionMode, encryptionKey = encryptionKey, versioningPolicyName = versioningPolicyName, creationDate = creationDate, lastSynchronizationDate = lastSynchronizationDate)

        return when (localVarResponse.responseType) {
            ResponseType.Success -> (localVarResponse as Success<*>).data as ObjectDataSource
            ResponseType.Informational -> throw UnsupportedOperationException("Client does not support Informational responses.")
            ResponseType.Redirection -> throw UnsupportedOperationException("Client does not support Redirection responses.")
            ResponseType.ClientError -> {
                val localVarError = localVarResponse as ClientError<*>
                throw ClientException("Client error : ${localVarError.statusCode} ${localVarError.message.orEmpty()}", localVarError.statusCode, localVarResponse)
            }
            ResponseType.ServerError -> {
                val localVarError = localVarResponse as ServerError<*>
                throw ServerException("Server error : ${localVarError.statusCode} ${localVarError.message.orEmpty()} ${localVarError.body}", localVarError.statusCode, localVarResponse)
            }
        }
    }

    /**
     * Load datasource information
     * 
     * @param name Name of the data source (max length 34)
     * @param disabled Whether this data source is disabled or running (optional)
     * @param storageType Type of underlying storage (LOCAL, S3, AZURE, GCS) (optional, default to LOCAL)
     * @param objectsServiceName Corresponding objects service name (underlying s3 service) (optional)
     * @param objectsHost Corresponding objects service host (optional)
     * @param objectsPort Corresponding objects service port (optional)
     * @param objectsSecure Corresponding objects service connection type (optional)
     * @param objectsBucket Corresponding objects service bucket (optional)
     * @param objectsBaseFolder Corresponding objects service base folder inside the bucket (optional)
     * @param apiKey Corresponding objects service api key (optional)
     * @param apiSecret Corresponding objects service api secret (optional)
     * @param peerAddress Peer address of the data source (optional)
     * @param watch Not implemented, whether to watch for underlying changes on the FS (optional)
     * @param flatStorage Store data in flat format (object-storage like) (optional)
     * @param skipSyncOnRestart Do not trigger resync at start (optional)
     * @param encryptionMode Type of encryption applied before sending data to storage (optional, default to CLEAR)
     * @param encryptionKey Encryption key used for encrypting data (optional)
     * @param versioningPolicyName Versioning policy describes how files are kept in the versioning queue (optional)
     * @param creationDate Data Source creation date (optional)
     * @param lastSynchronizationDate Data Source last synchronization date (optional)
     * @return ApiResponse<ObjectDataSource?>
     * @throws IllegalStateException If the request is not correctly configured
     * @throws IOException Rethrows the OkHttp execute method exception
     */
    @Suppress("UNCHECKED_CAST")
    @Throws(IllegalStateException::class, IOException::class)
    fun getDataSourceWithHttpInfo(name: kotlin.String, disabled: kotlin.Boolean?, storageType: StorageTypeGetDataSource?, objectsServiceName: kotlin.String?, objectsHost: kotlin.String?, objectsPort: kotlin.Int?, objectsSecure: kotlin.Boolean?, objectsBucket: kotlin.String?, objectsBaseFolder: kotlin.String?, apiKey: kotlin.String?, apiSecret: kotlin.String?, peerAddress: kotlin.String?, watch: kotlin.Boolean?, flatStorage: kotlin.Boolean?, skipSyncOnRestart: kotlin.Boolean?, encryptionMode: EncryptionModeGetDataSource?, encryptionKey: kotlin.String?, versioningPolicyName: kotlin.String?, creationDate: kotlin.Int?, lastSynchronizationDate: kotlin.Int?) : ApiResponse<ObjectDataSource?> {
        val localVariableConfig = getDataSourceRequestConfig(name = name, disabled = disabled, storageType = storageType, objectsServiceName = objectsServiceName, objectsHost = objectsHost, objectsPort = objectsPort, objectsSecure = objectsSecure, objectsBucket = objectsBucket, objectsBaseFolder = objectsBaseFolder, apiKey = apiKey, apiSecret = apiSecret, peerAddress = peerAddress, watch = watch, flatStorage = flatStorage, skipSyncOnRestart = skipSyncOnRestart, encryptionMode = encryptionMode, encryptionKey = encryptionKey, versioningPolicyName = versioningPolicyName, creationDate = creationDate, lastSynchronizationDate = lastSynchronizationDate)

        return request<Unit, ObjectDataSource>(
            localVariableConfig
        )
    }

    /**
     * To obtain the request config of the operation getDataSource
     *
     * @param name Name of the data source (max length 34)
     * @param disabled Whether this data source is disabled or running (optional)
     * @param storageType Type of underlying storage (LOCAL, S3, AZURE, GCS) (optional, default to LOCAL)
     * @param objectsServiceName Corresponding objects service name (underlying s3 service) (optional)
     * @param objectsHost Corresponding objects service host (optional)
     * @param objectsPort Corresponding objects service port (optional)
     * @param objectsSecure Corresponding objects service connection type (optional)
     * @param objectsBucket Corresponding objects service bucket (optional)
     * @param objectsBaseFolder Corresponding objects service base folder inside the bucket (optional)
     * @param apiKey Corresponding objects service api key (optional)
     * @param apiSecret Corresponding objects service api secret (optional)
     * @param peerAddress Peer address of the data source (optional)
     * @param watch Not implemented, whether to watch for underlying changes on the FS (optional)
     * @param flatStorage Store data in flat format (object-storage like) (optional)
     * @param skipSyncOnRestart Do not trigger resync at start (optional)
     * @param encryptionMode Type of encryption applied before sending data to storage (optional, default to CLEAR)
     * @param encryptionKey Encryption key used for encrypting data (optional)
     * @param versioningPolicyName Versioning policy describes how files are kept in the versioning queue (optional)
     * @param creationDate Data Source creation date (optional)
     * @param lastSynchronizationDate Data Source last synchronization date (optional)
     * @return RequestConfig
     */
    fun getDataSourceRequestConfig(name: kotlin.String, disabled: kotlin.Boolean?, storageType: StorageTypeGetDataSource?, objectsServiceName: kotlin.String?, objectsHost: kotlin.String?, objectsPort: kotlin.Int?, objectsSecure: kotlin.Boolean?, objectsBucket: kotlin.String?, objectsBaseFolder: kotlin.String?, apiKey: kotlin.String?, apiSecret: kotlin.String?, peerAddress: kotlin.String?, watch: kotlin.Boolean?, flatStorage: kotlin.Boolean?, skipSyncOnRestart: kotlin.Boolean?, encryptionMode: EncryptionModeGetDataSource?, encryptionKey: kotlin.String?, versioningPolicyName: kotlin.String?, creationDate: kotlin.Int?, lastSynchronizationDate: kotlin.Int?) : RequestConfig<Unit> {
        val localVariableBody = null
        val localVariableQuery: MultiValueMap = mutableMapOf<kotlin.String, kotlin.collections.List<kotlin.String>>()
            .apply {
                if (disabled != null) {
                    put("Disabled", listOf(disabled.toString()))
                }
                if (storageType != null) {
                    put("StorageType", listOf(storageType.value))
                }
                if (objectsServiceName != null) {
                    put("ObjectsServiceName", listOf(objectsServiceName.toString()))
                }
                if (objectsHost != null) {
                    put("ObjectsHost", listOf(objectsHost.toString()))
                }
                if (objectsPort != null) {
                    put("ObjectsPort", listOf(objectsPort.toString()))
                }
                if (objectsSecure != null) {
                    put("ObjectsSecure", listOf(objectsSecure.toString()))
                }
                if (objectsBucket != null) {
                    put("ObjectsBucket", listOf(objectsBucket.toString()))
                }
                if (objectsBaseFolder != null) {
                    put("ObjectsBaseFolder", listOf(objectsBaseFolder.toString()))
                }
                if (apiKey != null) {
                    put("ApiKey", listOf(apiKey.toString()))
                }
                if (apiSecret != null) {
                    put("ApiSecret", listOf(apiSecret.toString()))
                }
                if (peerAddress != null) {
                    put("PeerAddress", listOf(peerAddress.toString()))
                }
                if (watch != null) {
                    put("Watch", listOf(watch.toString()))
                }
                if (flatStorage != null) {
                    put("FlatStorage", listOf(flatStorage.toString()))
                }
                if (skipSyncOnRestart != null) {
                    put("SkipSyncOnRestart", listOf(skipSyncOnRestart.toString()))
                }
                if (encryptionMode != null) {
                    put("EncryptionMode", listOf(encryptionMode.value))
                }
                if (encryptionKey != null) {
                    put("EncryptionKey", listOf(encryptionKey.toString()))
                }
                if (versioningPolicyName != null) {
                    put("VersioningPolicyName", listOf(versioningPolicyName.toString()))
                }
                if (creationDate != null) {
                    put("CreationDate", listOf(creationDate.toString()))
                }
                if (lastSynchronizationDate != null) {
                    put("LastSynchronizationDate", listOf(lastSynchronizationDate.toString()))
                }
            }
        val localVariableHeaders: MutableMap<String, String> = mutableMapOf()
        localVariableHeaders["Accept"] = "application/json"

        return RequestConfig(
            method = RequestMethod.GET,
            path = "/config/datasource/{Name}".replace("{"+"Name"+"}", encodeURIComponent(name.toString())),
            query = localVariableQuery,
            headers = localVariableHeaders,
            requiresAuthentication = false,
            body = localVariableBody
        )
    }

    /**
     * enum for parameter nodeDeletedStrategy
     */
     enum class NodeDeletedStrategyGetVersioningPolicy(val value: kotlin.String) {
         @Json(name = "KeepAll") KeepAll("KeepAll"),
         @Json(name = "KeepLast") KeepLast("KeepLast"),
         @Json(name = "KeepNone") KeepNone("KeepNone")
     }

    /**
     * Load a given versioning policy
     * 
     * @param uuid 
     * @param name  (optional)
     * @param description  (optional)
     * @param versionsDataSourceName  (optional)
     * @param versionsDataSourceBucket  (optional)
     * @param maxTotalSize  (optional)
     * @param maxSizePerFile  (optional)
     * @param ignoreFilesGreaterThan  (optional)
     * @param nodeDeletedStrategy  (optional, default to KeepAll)
     * @return TreeVersioningPolicy
     * @throws IllegalStateException If the request is not correctly configured
     * @throws IOException Rethrows the OkHttp execute method exception
     * @throws UnsupportedOperationException If the API returns an informational or redirection response
     * @throws ClientException If the API returns a client error response
     * @throws ServerException If the API returns a server error response
     */
    @Suppress("UNCHECKED_CAST")
    @Throws(IllegalStateException::class, IOException::class, UnsupportedOperationException::class, ClientException::class, ServerException::class)
    fun getVersioningPolicy(uuid: kotlin.String, name: kotlin.String? = null, description: kotlin.String? = null, versionsDataSourceName: kotlin.String? = null, versionsDataSourceBucket: kotlin.String? = null, maxTotalSize: kotlin.String? = null, maxSizePerFile: kotlin.String? = null, ignoreFilesGreaterThan: kotlin.String? = null, nodeDeletedStrategy: NodeDeletedStrategyGetVersioningPolicy? = NodeDeletedStrategyGetVersioningPolicy.KeepAll) : TreeVersioningPolicy {
        val localVarResponse = getVersioningPolicyWithHttpInfo(uuid = uuid, name = name, description = description, versionsDataSourceName = versionsDataSourceName, versionsDataSourceBucket = versionsDataSourceBucket, maxTotalSize = maxTotalSize, maxSizePerFile = maxSizePerFile, ignoreFilesGreaterThan = ignoreFilesGreaterThan, nodeDeletedStrategy = nodeDeletedStrategy)

        return when (localVarResponse.responseType) {
            ResponseType.Success -> (localVarResponse as Success<*>).data as TreeVersioningPolicy
            ResponseType.Informational -> throw UnsupportedOperationException("Client does not support Informational responses.")
            ResponseType.Redirection -> throw UnsupportedOperationException("Client does not support Redirection responses.")
            ResponseType.ClientError -> {
                val localVarError = localVarResponse as ClientError<*>
                throw ClientException("Client error : ${localVarError.statusCode} ${localVarError.message.orEmpty()}", localVarError.statusCode, localVarResponse)
            }
            ResponseType.ServerError -> {
                val localVarError = localVarResponse as ServerError<*>
                throw ServerException("Server error : ${localVarError.statusCode} ${localVarError.message.orEmpty()} ${localVarError.body}", localVarError.statusCode, localVarResponse)
            }
        }
    }

    /**
     * Load a given versioning policy
     * 
     * @param uuid 
     * @param name  (optional)
     * @param description  (optional)
     * @param versionsDataSourceName  (optional)
     * @param versionsDataSourceBucket  (optional)
     * @param maxTotalSize  (optional)
     * @param maxSizePerFile  (optional)
     * @param ignoreFilesGreaterThan  (optional)
     * @param nodeDeletedStrategy  (optional, default to KeepAll)
     * @return ApiResponse<TreeVersioningPolicy?>
     * @throws IllegalStateException If the request is not correctly configured
     * @throws IOException Rethrows the OkHttp execute method exception
     */
    @Suppress("UNCHECKED_CAST")
    @Throws(IllegalStateException::class, IOException::class)
    fun getVersioningPolicyWithHttpInfo(uuid: kotlin.String, name: kotlin.String?, description: kotlin.String?, versionsDataSourceName: kotlin.String?, versionsDataSourceBucket: kotlin.String?, maxTotalSize: kotlin.String?, maxSizePerFile: kotlin.String?, ignoreFilesGreaterThan: kotlin.String?, nodeDeletedStrategy: NodeDeletedStrategyGetVersioningPolicy?) : ApiResponse<TreeVersioningPolicy?> {
        val localVariableConfig = getVersioningPolicyRequestConfig(uuid = uuid, name = name, description = description, versionsDataSourceName = versionsDataSourceName, versionsDataSourceBucket = versionsDataSourceBucket, maxTotalSize = maxTotalSize, maxSizePerFile = maxSizePerFile, ignoreFilesGreaterThan = ignoreFilesGreaterThan, nodeDeletedStrategy = nodeDeletedStrategy)

        return request<Unit, TreeVersioningPolicy>(
            localVariableConfig
        )
    }

    /**
     * To obtain the request config of the operation getVersioningPolicy
     *
     * @param uuid 
     * @param name  (optional)
     * @param description  (optional)
     * @param versionsDataSourceName  (optional)
     * @param versionsDataSourceBucket  (optional)
     * @param maxTotalSize  (optional)
     * @param maxSizePerFile  (optional)
     * @param ignoreFilesGreaterThan  (optional)
     * @param nodeDeletedStrategy  (optional, default to KeepAll)
     * @return RequestConfig
     */
    fun getVersioningPolicyRequestConfig(uuid: kotlin.String, name: kotlin.String?, description: kotlin.String?, versionsDataSourceName: kotlin.String?, versionsDataSourceBucket: kotlin.String?, maxTotalSize: kotlin.String?, maxSizePerFile: kotlin.String?, ignoreFilesGreaterThan: kotlin.String?, nodeDeletedStrategy: NodeDeletedStrategyGetVersioningPolicy?) : RequestConfig<Unit> {
        val localVariableBody = null
        val localVariableQuery: MultiValueMap = mutableMapOf<kotlin.String, kotlin.collections.List<kotlin.String>>()
            .apply {
                if (name != null) {
                    put("Name", listOf(name.toString()))
                }
                if (description != null) {
                    put("Description", listOf(description.toString()))
                }
                if (versionsDataSourceName != null) {
                    put("VersionsDataSourceName", listOf(versionsDataSourceName.toString()))
                }
                if (versionsDataSourceBucket != null) {
                    put("VersionsDataSourceBucket", listOf(versionsDataSourceBucket.toString()))
                }
                if (maxTotalSize != null) {
                    put("MaxTotalSize", listOf(maxTotalSize.toString()))
                }
                if (maxSizePerFile != null) {
                    put("MaxSizePerFile", listOf(maxSizePerFile.toString()))
                }
                if (ignoreFilesGreaterThan != null) {
                    put("IgnoreFilesGreaterThan", listOf(ignoreFilesGreaterThan.toString()))
                }
                if (nodeDeletedStrategy != null) {
                    put("NodeDeletedStrategy", listOf(nodeDeletedStrategy.value))
                }
            }
        val localVariableHeaders: MutableMap<String, String> = mutableMapOf()
        localVariableHeaders["Accept"] = "application/json"

        return RequestConfig(
            method = RequestMethod.GET,
            path = "/config/versioning/{Uuid}".replace("{"+"Uuid"+"}", encodeURIComponent(uuid.toString())),
            query = localVariableQuery,
            headers = localVariableHeaders,
            requiresAuthentication = false,
            body = localVariableBody
        )
    }

    /**
     * Import a previously exported master key, requires the password created at export time
     * 
     * @param body 
     * @return EncryptionAdminImportKeyResponse
     * @throws IllegalStateException If the request is not correctly configured
     * @throws IOException Rethrows the OkHttp execute method exception
     * @throws UnsupportedOperationException If the API returns an informational or redirection response
     * @throws ClientException If the API returns a client error response
     * @throws ServerException If the API returns a server error response
     */
    @Suppress("UNCHECKED_CAST")
    @Throws(IllegalStateException::class, IOException::class, UnsupportedOperationException::class, ClientException::class, ServerException::class)
    fun importEncryptionKey(body: EncryptionAdminImportKeyRequest) : EncryptionAdminImportKeyResponse {
        val localVarResponse = importEncryptionKeyWithHttpInfo(body = body)

        return when (localVarResponse.responseType) {
            ResponseType.Success -> (localVarResponse as Success<*>).data as EncryptionAdminImportKeyResponse
            ResponseType.Informational -> throw UnsupportedOperationException("Client does not support Informational responses.")
            ResponseType.Redirection -> throw UnsupportedOperationException("Client does not support Redirection responses.")
            ResponseType.ClientError -> {
                val localVarError = localVarResponse as ClientError<*>
                throw ClientException("Client error : ${localVarError.statusCode} ${localVarError.message.orEmpty()}", localVarError.statusCode, localVarResponse)
            }
            ResponseType.ServerError -> {
                val localVarError = localVarResponse as ServerError<*>
                throw ServerException("Server error : ${localVarError.statusCode} ${localVarError.message.orEmpty()} ${localVarError.body}", localVarError.statusCode, localVarResponse)
            }
        }
    }

    /**
     * Import a previously exported master key, requires the password created at export time
     * 
     * @param body 
     * @return ApiResponse<EncryptionAdminImportKeyResponse?>
     * @throws IllegalStateException If the request is not correctly configured
     * @throws IOException Rethrows the OkHttp execute method exception
     */
    @Suppress("UNCHECKED_CAST")
    @Throws(IllegalStateException::class, IOException::class)
    fun importEncryptionKeyWithHttpInfo(body: EncryptionAdminImportKeyRequest) : ApiResponse<EncryptionAdminImportKeyResponse?> {
        val localVariableConfig = importEncryptionKeyRequestConfig(body = body)

        return request<EncryptionAdminImportKeyRequest, EncryptionAdminImportKeyResponse>(
            localVariableConfig
        )
    }

    /**
     * To obtain the request config of the operation importEncryptionKey
     *
     * @param body 
     * @return RequestConfig
     */
    fun importEncryptionKeyRequestConfig(body: EncryptionAdminImportKeyRequest) : RequestConfig<EncryptionAdminImportKeyRequest> {
        val localVariableBody = body
        val localVariableQuery: MultiValueMap = mutableMapOf()
        val localVariableHeaders: MutableMap<String, String> = mutableMapOf()
        localVariableHeaders["Content-Type"] = "application/json"
        localVariableHeaders["Accept"] = "application/json"

        return RequestConfig(
            method = RequestMethod.PUT,
            path = "/config/encryption/import",
            query = localVariableQuery,
            headers = localVariableHeaders,
            requiresAuthentication = false,
            body = localVariableBody
        )
    }

    /**
     * List all defined datasources
     * 
     * @return RestDataSourceCollection
     * @throws IllegalStateException If the request is not correctly configured
     * @throws IOException Rethrows the OkHttp execute method exception
     * @throws UnsupportedOperationException If the API returns an informational or redirection response
     * @throws ClientException If the API returns a client error response
     * @throws ServerException If the API returns a server error response
     */
    @Suppress("UNCHECKED_CAST")
    @Throws(IllegalStateException::class, IOException::class, UnsupportedOperationException::class, ClientException::class, ServerException::class)
    fun listDataSources() : RestDataSourceCollection {
        val localVarResponse = listDataSourcesWithHttpInfo()

        return when (localVarResponse.responseType) {
            ResponseType.Success -> (localVarResponse as Success<*>).data as RestDataSourceCollection
            ResponseType.Informational -> throw UnsupportedOperationException("Client does not support Informational responses.")
            ResponseType.Redirection -> throw UnsupportedOperationException("Client does not support Redirection responses.")
            ResponseType.ClientError -> {
                val localVarError = localVarResponse as ClientError<*>
                throw ClientException("Client error : ${localVarError.statusCode} ${localVarError.message.orEmpty()}", localVarError.statusCode, localVarResponse)
            }
            ResponseType.ServerError -> {
                val localVarError = localVarResponse as ServerError<*>
                throw ServerException("Server error : ${localVarError.statusCode} ${localVarError.message.orEmpty()} ${localVarError.body}", localVarError.statusCode, localVarResponse)
            }
        }
    }

    /**
     * List all defined datasources
     * 
     * @return ApiResponse<RestDataSourceCollection?>
     * @throws IllegalStateException If the request is not correctly configured
     * @throws IOException Rethrows the OkHttp execute method exception
     */
    @Suppress("UNCHECKED_CAST")
    @Throws(IllegalStateException::class, IOException::class)
    fun listDataSourcesWithHttpInfo() : ApiResponse<RestDataSourceCollection?> {
        val localVariableConfig = listDataSourcesRequestConfig()

        return request<Unit, RestDataSourceCollection>(
            localVariableConfig
        )
    }

    /**
     * To obtain the request config of the operation listDataSources
     *
     * @return RequestConfig
     */
    fun listDataSourcesRequestConfig() : RequestConfig<Unit> {
        val localVariableBody = null
        val localVariableQuery: MultiValueMap = mutableMapOf()
        val localVariableHeaders: MutableMap<String, String> = mutableMapOf()
        localVariableHeaders["Accept"] = "application/json"

        return RequestConfig(
            method = RequestMethod.GET,
            path = "/config/datasource",
            query = localVariableQuery,
            headers = localVariableHeaders,
            requiresAuthentication = false,
            body = localVariableBody
        )
    }

    /**
     * List registered master keys
     * 
     * @param body 
     * @return EncryptionAdminListKeysResponse
     * @throws IllegalStateException If the request is not correctly configured
     * @throws IOException Rethrows the OkHttp execute method exception
     * @throws UnsupportedOperationException If the API returns an informational or redirection response
     * @throws ClientException If the API returns a client error response
     * @throws ServerException If the API returns a server error response
     */
    @Suppress("UNCHECKED_CAST")
    @Throws(IllegalStateException::class, IOException::class, UnsupportedOperationException::class, ClientException::class, ServerException::class)
    fun listEncryptionKeys(body: EncryptionAdminListKeysRequest) : EncryptionAdminListKeysResponse {
        val localVarResponse = listEncryptionKeysWithHttpInfo(body = body)

        return when (localVarResponse.responseType) {
            ResponseType.Success -> (localVarResponse as Success<*>).data as EncryptionAdminListKeysResponse
            ResponseType.Informational -> throw UnsupportedOperationException("Client does not support Informational responses.")
            ResponseType.Redirection -> throw UnsupportedOperationException("Client does not support Redirection responses.")
            ResponseType.ClientError -> {
                val localVarError = localVarResponse as ClientError<*>
                throw ClientException("Client error : ${localVarError.statusCode} ${localVarError.message.orEmpty()}", localVarError.statusCode, localVarResponse)
            }
            ResponseType.ServerError -> {
                val localVarError = localVarResponse as ServerError<*>
                throw ServerException("Server error : ${localVarError.statusCode} ${localVarError.message.orEmpty()} ${localVarError.body}", localVarError.statusCode, localVarResponse)
            }
        }
    }

    /**
     * List registered master keys
     * 
     * @param body 
     * @return ApiResponse<EncryptionAdminListKeysResponse?>
     * @throws IllegalStateException If the request is not correctly configured
     * @throws IOException Rethrows the OkHttp execute method exception
     */
    @Suppress("UNCHECKED_CAST")
    @Throws(IllegalStateException::class, IOException::class)
    fun listEncryptionKeysWithHttpInfo(body: EncryptionAdminListKeysRequest) : ApiResponse<EncryptionAdminListKeysResponse?> {
        val localVariableConfig = listEncryptionKeysRequestConfig(body = body)

        return request<EncryptionAdminListKeysRequest, EncryptionAdminListKeysResponse>(
            localVariableConfig
        )
    }

    /**
     * To obtain the request config of the operation listEncryptionKeys
     *
     * @param body 
     * @return RequestConfig
     */
    fun listEncryptionKeysRequestConfig(body: EncryptionAdminListKeysRequest) : RequestConfig<EncryptionAdminListKeysRequest> {
        val localVariableBody = body
        val localVariableQuery: MultiValueMap = mutableMapOf()
        val localVariableHeaders: MutableMap<String, String> = mutableMapOf()
        localVariableHeaders["Content-Type"] = "application/json"
        localVariableHeaders["Accept"] = "application/json"

        return RequestConfig(
            method = RequestMethod.POST,
            path = "/config/encryption/list",
            query = localVariableQuery,
            headers = localVariableHeaders,
            requiresAuthentication = false,
            body = localVariableBody
        )
    }

    /**
     * List folders on a peer, starting from root
     * 
     * @param peerAddress Restrict listing to a given peer
     * @param body 
     * @return RestNodesCollection
     * @throws IllegalStateException If the request is not correctly configured
     * @throws IOException Rethrows the OkHttp execute method exception
     * @throws UnsupportedOperationException If the API returns an informational or redirection response
     * @throws ClientException If the API returns a client error response
     * @throws ServerException If the API returns a server error response
     */
    @Suppress("UNCHECKED_CAST")
    @Throws(IllegalStateException::class, IOException::class, UnsupportedOperationException::class, ClientException::class, ServerException::class)
    fun listPeerFolders(peerAddress: kotlin.String, body: RestListPeerFoldersRequest) : RestNodesCollection {
        val localVarResponse = listPeerFoldersWithHttpInfo(peerAddress = peerAddress, body = body)

        return when (localVarResponse.responseType) {
            ResponseType.Success -> (localVarResponse as Success<*>).data as RestNodesCollection
            ResponseType.Informational -> throw UnsupportedOperationException("Client does not support Informational responses.")
            ResponseType.Redirection -> throw UnsupportedOperationException("Client does not support Redirection responses.")
            ResponseType.ClientError -> {
                val localVarError = localVarResponse as ClientError<*>
                throw ClientException("Client error : ${localVarError.statusCode} ${localVarError.message.orEmpty()}", localVarError.statusCode, localVarResponse)
            }
            ResponseType.ServerError -> {
                val localVarError = localVarResponse as ServerError<*>
                throw ServerException("Server error : ${localVarError.statusCode} ${localVarError.message.orEmpty()} ${localVarError.body}", localVarError.statusCode, localVarResponse)
            }
        }
    }

    /**
     * List folders on a peer, starting from root
     * 
     * @param peerAddress Restrict listing to a given peer
     * @param body 
     * @return ApiResponse<RestNodesCollection?>
     * @throws IllegalStateException If the request is not correctly configured
     * @throws IOException Rethrows the OkHttp execute method exception
     */
    @Suppress("UNCHECKED_CAST")
    @Throws(IllegalStateException::class, IOException::class)
    fun listPeerFoldersWithHttpInfo(peerAddress: kotlin.String, body: RestListPeerFoldersRequest) : ApiResponse<RestNodesCollection?> {
        val localVariableConfig = listPeerFoldersRequestConfig(peerAddress = peerAddress, body = body)

        return request<RestListPeerFoldersRequest, RestNodesCollection>(
            localVariableConfig
        )
    }

    /**
     * To obtain the request config of the operation listPeerFolders
     *
     * @param peerAddress Restrict listing to a given peer
     * @param body 
     * @return RequestConfig
     */
    fun listPeerFoldersRequestConfig(peerAddress: kotlin.String, body: RestListPeerFoldersRequest) : RequestConfig<RestListPeerFoldersRequest> {
        val localVariableBody = body
        val localVariableQuery: MultiValueMap = mutableMapOf()
        val localVariableHeaders: MutableMap<String, String> = mutableMapOf()
        localVariableHeaders["Content-Type"] = "application/json"
        localVariableHeaders["Accept"] = "application/json"

        return RequestConfig(
            method = RequestMethod.POST,
            path = "/config/peers/{PeerAddress}".replace("{"+"PeerAddress"+"}", encodeURIComponent(peerAddress.toString())),
            query = localVariableQuery,
            headers = localVariableHeaders,
            requiresAuthentication = false,
            body = localVariableBody
        )
    }

    /**
     * List all detected peers (servers on which the app is running)
     * 
     * @return RestListPeersAddressesResponse
     * @throws IllegalStateException If the request is not correctly configured
     * @throws IOException Rethrows the OkHttp execute method exception
     * @throws UnsupportedOperationException If the API returns an informational or redirection response
     * @throws ClientException If the API returns a client error response
     * @throws ServerException If the API returns a server error response
     */
    @Suppress("UNCHECKED_CAST")
    @Throws(IllegalStateException::class, IOException::class, UnsupportedOperationException::class, ClientException::class, ServerException::class)
    fun listPeersAddresses() : RestListPeersAddressesResponse {
        val localVarResponse = listPeersAddressesWithHttpInfo()

        return when (localVarResponse.responseType) {
            ResponseType.Success -> (localVarResponse as Success<*>).data as RestListPeersAddressesResponse
            ResponseType.Informational -> throw UnsupportedOperationException("Client does not support Informational responses.")
            ResponseType.Redirection -> throw UnsupportedOperationException("Client does not support Redirection responses.")
            ResponseType.ClientError -> {
                val localVarError = localVarResponse as ClientError<*>
                throw ClientException("Client error : ${localVarError.statusCode} ${localVarError.message.orEmpty()}", localVarError.statusCode, localVarResponse)
            }
            ResponseType.ServerError -> {
                val localVarError = localVarResponse as ServerError<*>
                throw ServerException("Server error : ${localVarError.statusCode} ${localVarError.message.orEmpty()} ${localVarError.body}", localVarError.statusCode, localVarResponse)
            }
        }
    }

    /**
     * List all detected peers (servers on which the app is running)
     * 
     * @return ApiResponse<RestListPeersAddressesResponse?>
     * @throws IllegalStateException If the request is not correctly configured
     * @throws IOException Rethrows the OkHttp execute method exception
     */
    @Suppress("UNCHECKED_CAST")
    @Throws(IllegalStateException::class, IOException::class)
    fun listPeersAddressesWithHttpInfo() : ApiResponse<RestListPeersAddressesResponse?> {
        val localVariableConfig = listPeersAddressesRequestConfig()

        return request<Unit, RestListPeersAddressesResponse>(
            localVariableConfig
        )
    }

    /**
     * To obtain the request config of the operation listPeersAddresses
     *
     * @return RequestConfig
     */
    fun listPeersAddressesRequestConfig() : RequestConfig<Unit> {
        val localVariableBody = null
        val localVariableQuery: MultiValueMap = mutableMapOf()
        val localVariableHeaders: MutableMap<String, String> = mutableMapOf()
        localVariableHeaders["Accept"] = "application/json"

        return RequestConfig(
            method = RequestMethod.GET,
            path = "/config/peers",
            query = localVariableQuery,
            headers = localVariableHeaders,
            requiresAuthentication = false,
            body = localVariableBody
        )
    }

    /**
     * List running Processes, with option PeerId or ServiceName filter
     * 
     * @param body 
     * @return RestListProcessesResponse
     * @throws IllegalStateException If the request is not correctly configured
     * @throws IOException Rethrows the OkHttp execute method exception
     * @throws UnsupportedOperationException If the API returns an informational or redirection response
     * @throws ClientException If the API returns a client error response
     * @throws ServerException If the API returns a server error response
     */
    @Suppress("UNCHECKED_CAST")
    @Throws(IllegalStateException::class, IOException::class, UnsupportedOperationException::class, ClientException::class, ServerException::class)
    fun listProcesses(body: RestListProcessesRequest) : RestListProcessesResponse {
        val localVarResponse = listProcessesWithHttpInfo(body = body)

        return when (localVarResponse.responseType) {
            ResponseType.Success -> (localVarResponse as Success<*>).data as RestListProcessesResponse
            ResponseType.Informational -> throw UnsupportedOperationException("Client does not support Informational responses.")
            ResponseType.Redirection -> throw UnsupportedOperationException("Client does not support Redirection responses.")
            ResponseType.ClientError -> {
                val localVarError = localVarResponse as ClientError<*>
                throw ClientException("Client error : ${localVarError.statusCode} ${localVarError.message.orEmpty()}", localVarError.statusCode, localVarResponse)
            }
            ResponseType.ServerError -> {
                val localVarError = localVarResponse as ServerError<*>
                throw ServerException("Server error : ${localVarError.statusCode} ${localVarError.message.orEmpty()} ${localVarError.body}", localVarError.statusCode, localVarResponse)
            }
        }
    }

    /**
     * List running Processes, with option PeerId or ServiceName filter
     * 
     * @param body 
     * @return ApiResponse<RestListProcessesResponse?>
     * @throws IllegalStateException If the request is not correctly configured
     * @throws IOException Rethrows the OkHttp execute method exception
     */
    @Suppress("UNCHECKED_CAST")
    @Throws(IllegalStateException::class, IOException::class)
    fun listProcessesWithHttpInfo(body: RestListProcessesRequest) : ApiResponse<RestListProcessesResponse?> {
        val localVariableConfig = listProcessesRequestConfig(body = body)

        return request<RestListProcessesRequest, RestListProcessesResponse>(
            localVariableConfig
        )
    }

    /**
     * To obtain the request config of the operation listProcesses
     *
     * @param body 
     * @return RequestConfig
     */
    fun listProcessesRequestConfig(body: RestListProcessesRequest) : RequestConfig<RestListProcessesRequest> {
        val localVariableBody = body
        val localVariableQuery: MultiValueMap = mutableMapOf()
        val localVariableHeaders: MutableMap<String, String> = mutableMapOf()
        localVariableHeaders["Content-Type"] = "application/json"
        localVariableHeaders["Accept"] = "application/json"

        return RequestConfig(
            method = RequestMethod.POST,
            path = "/config/processes",
            query = localVariableQuery,
            headers = localVariableHeaders,
            requiresAuthentication = false,
            body = localVariableBody
        )
    }

    /**
     * 
     * 
     * @param body 
     * @return RegistryListResponse
     * @throws IllegalStateException If the request is not correctly configured
     * @throws IOException Rethrows the OkHttp execute method exception
     * @throws UnsupportedOperationException If the API returns an informational or redirection response
     * @throws ClientException If the API returns a client error response
     * @throws ServerException If the API returns a server error response
     */
    @Suppress("UNCHECKED_CAST")
    @Throws(IllegalStateException::class, IOException::class, UnsupportedOperationException::class, ClientException::class, ServerException::class)
    fun listRegistry(body: RegistryListRequest) : RegistryListResponse {
        val localVarResponse = listRegistryWithHttpInfo(body = body)

        return when (localVarResponse.responseType) {
            ResponseType.Success -> (localVarResponse as Success<*>).data as RegistryListResponse
            ResponseType.Informational -> throw UnsupportedOperationException("Client does not support Informational responses.")
            ResponseType.Redirection -> throw UnsupportedOperationException("Client does not support Redirection responses.")
            ResponseType.ClientError -> {
                val localVarError = localVarResponse as ClientError<*>
                throw ClientException("Client error : ${localVarError.statusCode} ${localVarError.message.orEmpty()}", localVarError.statusCode, localVarResponse)
            }
            ResponseType.ServerError -> {
                val localVarError = localVarResponse as ServerError<*>
                throw ServerException("Server error : ${localVarError.statusCode} ${localVarError.message.orEmpty()} ${localVarError.body}", localVarError.statusCode, localVarResponse)
            }
        }
    }

    /**
     * 
     * 
     * @param body 
     * @return ApiResponse<RegistryListResponse?>
     * @throws IllegalStateException If the request is not correctly configured
     * @throws IOException Rethrows the OkHttp execute method exception
     */
    @Suppress("UNCHECKED_CAST")
    @Throws(IllegalStateException::class, IOException::class)
    fun listRegistryWithHttpInfo(body: RegistryListRequest) : ApiResponse<RegistryListResponse?> {
        val localVariableConfig = listRegistryRequestConfig(body = body)

        return request<RegistryListRequest, RegistryListResponse>(
            localVariableConfig
        )
    }

    /**
     * To obtain the request config of the operation listRegistry
     *
     * @param body 
     * @return RequestConfig
     */
    fun listRegistryRequestConfig(body: RegistryListRequest) : RequestConfig<RegistryListRequest> {
        val localVariableBody = body
        val localVariableQuery: MultiValueMap = mutableMapOf()
        val localVariableHeaders: MutableMap<String, String> = mutableMapOf()
        localVariableHeaders["Content-Type"] = "application/json"
        localVariableHeaders["Accept"] = "application/json"

        return RequestConfig(
            method = RequestMethod.POST,
            path = "/config/registry",
            query = localVariableQuery,
            headers = localVariableHeaders,
            requiresAuthentication = false,
            body = localVariableBody
        )
    }

    /**
     * enum for parameter statusFilter
     */
     enum class StatusFilterListServices(val value: kotlin.String) {
         @Json(name = "ANY") ANY("ANY"),
         @Json(name = "STOPPED") STOPPED("STOPPED"),
         @Json(name = "STARTING") STARTING("STARTING"),
         @Json(name = "STOPPING") STOPPING("STOPPING"),
         @Json(name = "STARTED") STARTED("STARTED")
     }

    /**
     * List all services and their status
     * 
     * @param statusFilter Filter services by a given status (ANY, STOPPED, STOPPING, RUNNING) (optional, default to ANY)
     * @return RestServiceCollection
     * @throws IllegalStateException If the request is not correctly configured
     * @throws IOException Rethrows the OkHttp execute method exception
     * @throws UnsupportedOperationException If the API returns an informational or redirection response
     * @throws ClientException If the API returns a client error response
     * @throws ServerException If the API returns a server error response
     */
    @Suppress("UNCHECKED_CAST")
    @Throws(IllegalStateException::class, IOException::class, UnsupportedOperationException::class, ClientException::class, ServerException::class)
    fun listServices(statusFilter: StatusFilterListServices? = StatusFilterListServices.ANY) : RestServiceCollection {
        val localVarResponse = listServicesWithHttpInfo(statusFilter = statusFilter)

        return when (localVarResponse.responseType) {
            ResponseType.Success -> (localVarResponse as Success<*>).data as RestServiceCollection
            ResponseType.Informational -> throw UnsupportedOperationException("Client does not support Informational responses.")
            ResponseType.Redirection -> throw UnsupportedOperationException("Client does not support Redirection responses.")
            ResponseType.ClientError -> {
                val localVarError = localVarResponse as ClientError<*>
                throw ClientException("Client error : ${localVarError.statusCode} ${localVarError.message.orEmpty()}", localVarError.statusCode, localVarResponse)
            }
            ResponseType.ServerError -> {
                val localVarError = localVarResponse as ServerError<*>
                throw ServerException("Server error : ${localVarError.statusCode} ${localVarError.message.orEmpty()} ${localVarError.body}", localVarError.statusCode, localVarResponse)
            }
        }
    }

    /**
     * List all services and their status
     * 
     * @param statusFilter Filter services by a given status (ANY, STOPPED, STOPPING, RUNNING) (optional, default to ANY)
     * @return ApiResponse<RestServiceCollection?>
     * @throws IllegalStateException If the request is not correctly configured
     * @throws IOException Rethrows the OkHttp execute method exception
     */
    @Suppress("UNCHECKED_CAST")
    @Throws(IllegalStateException::class, IOException::class)
    fun listServicesWithHttpInfo(statusFilter: StatusFilterListServices?) : ApiResponse<RestServiceCollection?> {
        val localVariableConfig = listServicesRequestConfig(statusFilter = statusFilter)

        return request<Unit, RestServiceCollection>(
            localVariableConfig
        )
    }

    /**
     * To obtain the request config of the operation listServices
     *
     * @param statusFilter Filter services by a given status (ANY, STOPPED, STOPPING, RUNNING) (optional, default to ANY)
     * @return RequestConfig
     */
    fun listServicesRequestConfig(statusFilter: StatusFilterListServices?) : RequestConfig<Unit> {
        val localVariableBody = null
        val localVariableQuery: MultiValueMap = mutableMapOf<kotlin.String, kotlin.collections.List<kotlin.String>>()
            .apply {
                if (statusFilter != null) {
                    put("StatusFilter", listOf(statusFilter.value))
                }
            }
        val localVariableHeaders: MutableMap<String, String> = mutableMapOf()
        localVariableHeaders["Accept"] = "application/json"

        return RequestConfig(
            method = RequestMethod.GET,
            path = "/config/ctl",
            query = localVariableQuery,
            headers = localVariableHeaders,
            requiresAuthentication = false,
            body = localVariableBody
        )
    }

    /**
     * List configured sites
     * 
     * @param filter 
     * @return RestListSitesResponse
     * @throws IllegalStateException If the request is not correctly configured
     * @throws IOException Rethrows the OkHttp execute method exception
     * @throws UnsupportedOperationException If the API returns an informational or redirection response
     * @throws ClientException If the API returns a client error response
     * @throws ServerException If the API returns a server error response
     */
    @Suppress("UNCHECKED_CAST")
    @Throws(IllegalStateException::class, IOException::class, UnsupportedOperationException::class, ClientException::class, ServerException::class)
    fun listSites(filter: kotlin.String) : RestListSitesResponse {
        val localVarResponse = listSitesWithHttpInfo(filter = filter)

        return when (localVarResponse.responseType) {
            ResponseType.Success -> (localVarResponse as Success<*>).data as RestListSitesResponse
            ResponseType.Informational -> throw UnsupportedOperationException("Client does not support Informational responses.")
            ResponseType.Redirection -> throw UnsupportedOperationException("Client does not support Redirection responses.")
            ResponseType.ClientError -> {
                val localVarError = localVarResponse as ClientError<*>
                throw ClientException("Client error : ${localVarError.statusCode} ${localVarError.message.orEmpty()}", localVarError.statusCode, localVarResponse)
            }
            ResponseType.ServerError -> {
                val localVarError = localVarResponse as ServerError<*>
                throw ServerException("Server error : ${localVarError.statusCode} ${localVarError.message.orEmpty()} ${localVarError.body}", localVarError.statusCode, localVarResponse)
            }
        }
    }

    /**
     * List configured sites
     * 
     * @param filter 
     * @return ApiResponse<RestListSitesResponse?>
     * @throws IllegalStateException If the request is not correctly configured
     * @throws IOException Rethrows the OkHttp execute method exception
     */
    @Suppress("UNCHECKED_CAST")
    @Throws(IllegalStateException::class, IOException::class)
    fun listSitesWithHttpInfo(filter: kotlin.String) : ApiResponse<RestListSitesResponse?> {
        val localVariableConfig = listSitesRequestConfig(filter = filter)

        return request<Unit, RestListSitesResponse>(
            localVariableConfig
        )
    }

    /**
     * To obtain the request config of the operation listSites
     *
     * @param filter 
     * @return RequestConfig
     */
    fun listSitesRequestConfig(filter: kotlin.String) : RequestConfig<Unit> {
        val localVariableBody = null
        val localVariableQuery: MultiValueMap = mutableMapOf()
        val localVariableHeaders: MutableMap<String, String> = mutableMapOf()
        localVariableHeaders["Accept"] = "application/json"

        return RequestConfig(
            method = RequestMethod.GET,
            path = "/config/sites/{Filter}".replace("{"+"Filter"+"}", encodeURIComponent(filter.toString())),
            query = localVariableQuery,
            headers = localVariableHeaders,
            requiresAuthentication = false,
            body = localVariableBody
        )
    }

    /**
     * List Buckets on a given object storage
     * 
     * @param body 
     * @return RestNodesCollection
     * @throws IllegalStateException If the request is not correctly configured
     * @throws IOException Rethrows the OkHttp execute method exception
     * @throws UnsupportedOperationException If the API returns an informational or redirection response
     * @throws ClientException If the API returns a client error response
     * @throws ServerException If the API returns a server error response
     */
    @Suppress("UNCHECKED_CAST")
    @Throws(IllegalStateException::class, IOException::class, UnsupportedOperationException::class, ClientException::class, ServerException::class)
    fun listStorageBuckets(body: RestListStorageBucketsRequest) : RestNodesCollection {
        val localVarResponse = listStorageBucketsWithHttpInfo(body = body)

        return when (localVarResponse.responseType) {
            ResponseType.Success -> (localVarResponse as Success<*>).data as RestNodesCollection
            ResponseType.Informational -> throw UnsupportedOperationException("Client does not support Informational responses.")
            ResponseType.Redirection -> throw UnsupportedOperationException("Client does not support Redirection responses.")
            ResponseType.ClientError -> {
                val localVarError = localVarResponse as ClientError<*>
                throw ClientException("Client error : ${localVarError.statusCode} ${localVarError.message.orEmpty()}", localVarError.statusCode, localVarResponse)
            }
            ResponseType.ServerError -> {
                val localVarError = localVarResponse as ServerError<*>
                throw ServerException("Server error : ${localVarError.statusCode} ${localVarError.message.orEmpty()} ${localVarError.body}", localVarError.statusCode, localVarResponse)
            }
        }
    }

    /**
     * List Buckets on a given object storage
     * 
     * @param body 
     * @return ApiResponse<RestNodesCollection?>
     * @throws IllegalStateException If the request is not correctly configured
     * @throws IOException Rethrows the OkHttp execute method exception
     */
    @Suppress("UNCHECKED_CAST")
    @Throws(IllegalStateException::class, IOException::class)
    fun listStorageBucketsWithHttpInfo(body: RestListStorageBucketsRequest) : ApiResponse<RestNodesCollection?> {
        val localVariableConfig = listStorageBucketsRequestConfig(body = body)

        return request<RestListStorageBucketsRequest, RestNodesCollection>(
            localVariableConfig
        )
    }

    /**
     * To obtain the request config of the operation listStorageBuckets
     *
     * @param body 
     * @return RequestConfig
     */
    fun listStorageBucketsRequestConfig(body: RestListStorageBucketsRequest) : RequestConfig<RestListStorageBucketsRequest> {
        val localVariableBody = body
        val localVariableQuery: MultiValueMap = mutableMapOf()
        val localVariableHeaders: MutableMap<String, String> = mutableMapOf()
        localVariableHeaders["Content-Type"] = "application/json"
        localVariableHeaders["Accept"] = "application/json"

        return RequestConfig(
            method = RequestMethod.POST,
            path = "/config/buckets",
            query = localVariableQuery,
            headers = localVariableHeaders,
            requiresAuthentication = false,
            body = localVariableBody
        )
    }

    /**
     * List all defined versioning policies
     * 
     * @return RestVersioningPolicyCollection
     * @throws IllegalStateException If the request is not correctly configured
     * @throws IOException Rethrows the OkHttp execute method exception
     * @throws UnsupportedOperationException If the API returns an informational or redirection response
     * @throws ClientException If the API returns a client error response
     * @throws ServerException If the API returns a server error response
     */
    @Suppress("UNCHECKED_CAST")
    @Throws(IllegalStateException::class, IOException::class, UnsupportedOperationException::class, ClientException::class, ServerException::class)
    fun listVersioningPolicies() : RestVersioningPolicyCollection {
        val localVarResponse = listVersioningPoliciesWithHttpInfo()

        return when (localVarResponse.responseType) {
            ResponseType.Success -> (localVarResponse as Success<*>).data as RestVersioningPolicyCollection
            ResponseType.Informational -> throw UnsupportedOperationException("Client does not support Informational responses.")
            ResponseType.Redirection -> throw UnsupportedOperationException("Client does not support Redirection responses.")
            ResponseType.ClientError -> {
                val localVarError = localVarResponse as ClientError<*>
                throw ClientException("Client error : ${localVarError.statusCode} ${localVarError.message.orEmpty()}", localVarError.statusCode, localVarResponse)
            }
            ResponseType.ServerError -> {
                val localVarError = localVarResponse as ServerError<*>
                throw ServerException("Server error : ${localVarError.statusCode} ${localVarError.message.orEmpty()} ${localVarError.body}", localVarError.statusCode, localVarResponse)
            }
        }
    }

    /**
     * List all defined versioning policies
     * 
     * @return ApiResponse<RestVersioningPolicyCollection?>
     * @throws IllegalStateException If the request is not correctly configured
     * @throws IOException Rethrows the OkHttp execute method exception
     */
    @Suppress("UNCHECKED_CAST")
    @Throws(IllegalStateException::class, IOException::class)
    fun listVersioningPoliciesWithHttpInfo() : ApiResponse<RestVersioningPolicyCollection?> {
        val localVariableConfig = listVersioningPoliciesRequestConfig()

        return request<Unit, RestVersioningPolicyCollection>(
            localVariableConfig
        )
    }

    /**
     * To obtain the request config of the operation listVersioningPolicies
     *
     * @return RequestConfig
     */
    fun listVersioningPoliciesRequestConfig() : RequestConfig<Unit> {
        val localVariableBody = null
        val localVariableQuery: MultiValueMap = mutableMapOf()
        val localVariableHeaders: MutableMap<String, String> = mutableMapOf()
        localVariableHeaders["Accept"] = "application/json"

        return RequestConfig(
            method = RequestMethod.GET,
            path = "/config/versioning",
            query = localVariableQuery,
            headers = localVariableHeaders,
            requiresAuthentication = false,
            body = localVariableBody
        )
    }

    /**
     * List all defined virtual nodes
     * 
     * @return RestNodesCollection
     * @throws IllegalStateException If the request is not correctly configured
     * @throws IOException Rethrows the OkHttp execute method exception
     * @throws UnsupportedOperationException If the API returns an informational or redirection response
     * @throws ClientException If the API returns a client error response
     * @throws ServerException If the API returns a server error response
     */
    @Suppress("UNCHECKED_CAST")
    @Throws(IllegalStateException::class, IOException::class, UnsupportedOperationException::class, ClientException::class, ServerException::class)
    fun listVirtualNodes() : RestNodesCollection {
        val localVarResponse = listVirtualNodesWithHttpInfo()

        return when (localVarResponse.responseType) {
            ResponseType.Success -> (localVarResponse as Success<*>).data as RestNodesCollection
            ResponseType.Informational -> throw UnsupportedOperationException("Client does not support Informational responses.")
            ResponseType.Redirection -> throw UnsupportedOperationException("Client does not support Redirection responses.")
            ResponseType.ClientError -> {
                val localVarError = localVarResponse as ClientError<*>
                throw ClientException("Client error : ${localVarError.statusCode} ${localVarError.message.orEmpty()}", localVarError.statusCode, localVarResponse)
            }
            ResponseType.ServerError -> {
                val localVarError = localVarResponse as ServerError<*>
                throw ServerException("Server error : ${localVarError.statusCode} ${localVarError.message.orEmpty()} ${localVarError.body}", localVarError.statusCode, localVarResponse)
            }
        }
    }

    /**
     * List all defined virtual nodes
     * 
     * @return ApiResponse<RestNodesCollection?>
     * @throws IllegalStateException If the request is not correctly configured
     * @throws IOException Rethrows the OkHttp execute method exception
     */
    @Suppress("UNCHECKED_CAST")
    @Throws(IllegalStateException::class, IOException::class)
    fun listVirtualNodesWithHttpInfo() : ApiResponse<RestNodesCollection?> {
        val localVariableConfig = listVirtualNodesRequestConfig()

        return request<Unit, RestNodesCollection>(
            localVariableConfig
        )
    }

    /**
     * To obtain the request config of the operation listVirtualNodes
     *
     * @return RequestConfig
     */
    fun listVirtualNodesRequestConfig() : RequestConfig<Unit> {
        val localVariableBody = null
        val localVariableQuery: MultiValueMap = mutableMapOf()
        val localVariableHeaders: MutableMap<String, String> = mutableMapOf()
        localVariableHeaders["Accept"] = "application/json"

        return RequestConfig(
            method = RequestMethod.GET,
            path = "/config/virtualnodes",
            query = localVariableQuery,
            headers = localVariableHeaders,
            requiresAuthentication = false,
            body = localVariableBody
        )
    }

    /**
     * Publish available REST APIs
     * 
     * @param endpointType Filter result to a specific endpoint type (optional)
     * @return RestOpenApiResponse
     * @throws IllegalStateException If the request is not correctly configured
     * @throws IOException Rethrows the OkHttp execute method exception
     * @throws UnsupportedOperationException If the API returns an informational or redirection response
     * @throws ClientException If the API returns a client error response
     * @throws ServerException If the API returns a server error response
     */
    @Suppress("UNCHECKED_CAST")
    @Throws(IllegalStateException::class, IOException::class, UnsupportedOperationException::class, ClientException::class, ServerException::class)
    fun openApiDiscovery(endpointType: kotlin.String? = null) : RestOpenApiResponse {
        val localVarResponse = openApiDiscoveryWithHttpInfo(endpointType = endpointType)

        return when (localVarResponse.responseType) {
            ResponseType.Success -> (localVarResponse as Success<*>).data as RestOpenApiResponse
            ResponseType.Informational -> throw UnsupportedOperationException("Client does not support Informational responses.")
            ResponseType.Redirection -> throw UnsupportedOperationException("Client does not support Redirection responses.")
            ResponseType.ClientError -> {
                val localVarError = localVarResponse as ClientError<*>
                throw ClientException("Client error : ${localVarError.statusCode} ${localVarError.message.orEmpty()}", localVarError.statusCode, localVarResponse)
            }
            ResponseType.ServerError -> {
                val localVarError = localVarResponse as ServerError<*>
                throw ServerException("Server error : ${localVarError.statusCode} ${localVarError.message.orEmpty()} ${localVarError.body}", localVarError.statusCode, localVarResponse)
            }
        }
    }

    /**
     * Publish available REST APIs
     * 
     * @param endpointType Filter result to a specific endpoint type (optional)
     * @return ApiResponse<RestOpenApiResponse?>
     * @throws IllegalStateException If the request is not correctly configured
     * @throws IOException Rethrows the OkHttp execute method exception
     */
    @Suppress("UNCHECKED_CAST")
    @Throws(IllegalStateException::class, IOException::class)
    fun openApiDiscoveryWithHttpInfo(endpointType: kotlin.String?) : ApiResponse<RestOpenApiResponse?> {
        val localVariableConfig = openApiDiscoveryRequestConfig(endpointType = endpointType)

        return request<Unit, RestOpenApiResponse>(
            localVariableConfig
        )
    }

    /**
     * To obtain the request config of the operation openApiDiscovery
     *
     * @param endpointType Filter result to a specific endpoint type (optional)
     * @return RequestConfig
     */
    fun openApiDiscoveryRequestConfig(endpointType: kotlin.String?) : RequestConfig<Unit> {
        val localVariableBody = null
        val localVariableQuery: MultiValueMap = mutableMapOf<kotlin.String, kotlin.collections.List<kotlin.String>>()
            .apply {
                if (endpointType != null) {
                    put("EndpointType", listOf(endpointType.toString()))
                }
            }
        val localVariableHeaders: MutableMap<String, String> = mutableMapOf()
        localVariableHeaders["Accept"] = "application/json"

        return RequestConfig(
            method = RequestMethod.GET,
            path = "/config/discovery/openapi",
            query = localVariableQuery,
            headers = localVariableHeaders,
            requiresAuthentication = false,
            body = localVariableBody
        )
    }

    /**
     * Generic config Put, using a full path in the config tree
     * 
     * @param fullPath Full slash-separated path to the config key
     * @param body 
     * @return RestConfiguration
     * @throws IllegalStateException If the request is not correctly configured
     * @throws IOException Rethrows the OkHttp execute method exception
     * @throws UnsupportedOperationException If the API returns an informational or redirection response
     * @throws ClientException If the API returns a client error response
     * @throws ServerException If the API returns a server error response
     */
    @Suppress("UNCHECKED_CAST")
    @Throws(IllegalStateException::class, IOException::class, UnsupportedOperationException::class, ClientException::class, ServerException::class)
    fun putConfig(fullPath: kotlin.String, body: ConfigurationMessageDataIsAnJsonRepresentationOfAnyValue) : RestConfiguration {
        val localVarResponse = putConfigWithHttpInfo(fullPath = fullPath, body = body)

        return when (localVarResponse.responseType) {
            ResponseType.Success -> (localVarResponse as Success<*>).data as RestConfiguration
            ResponseType.Informational -> throw UnsupportedOperationException("Client does not support Informational responses.")
            ResponseType.Redirection -> throw UnsupportedOperationException("Client does not support Redirection responses.")
            ResponseType.ClientError -> {
                val localVarError = localVarResponse as ClientError<*>
                throw ClientException("Client error : ${localVarError.statusCode} ${localVarError.message.orEmpty()}", localVarError.statusCode, localVarResponse)
            }
            ResponseType.ServerError -> {
                val localVarError = localVarResponse as ServerError<*>
                throw ServerException("Server error : ${localVarError.statusCode} ${localVarError.message.orEmpty()} ${localVarError.body}", localVarError.statusCode, localVarResponse)
            }
        }
    }

    /**
     * Generic config Put, using a full path in the config tree
     * 
     * @param fullPath Full slash-separated path to the config key
     * @param body 
     * @return ApiResponse<RestConfiguration?>
     * @throws IllegalStateException If the request is not correctly configured
     * @throws IOException Rethrows the OkHttp execute method exception
     */
    @Suppress("UNCHECKED_CAST")
    @Throws(IllegalStateException::class, IOException::class)
    fun putConfigWithHttpInfo(fullPath: kotlin.String, body: ConfigurationMessageDataIsAnJsonRepresentationOfAnyValue) : ApiResponse<RestConfiguration?> {
        val localVariableConfig = putConfigRequestConfig(fullPath = fullPath, body = body)

        return request<ConfigurationMessageDataIsAnJsonRepresentationOfAnyValue, RestConfiguration>(
            localVariableConfig
        )
    }

    /**
     * To obtain the request config of the operation putConfig
     *
     * @param fullPath Full slash-separated path to the config key
     * @param body 
     * @return RequestConfig
     */
    fun putConfigRequestConfig(fullPath: kotlin.String, body: ConfigurationMessageDataIsAnJsonRepresentationOfAnyValue) : RequestConfig<ConfigurationMessageDataIsAnJsonRepresentationOfAnyValue> {
        val localVariableBody = body
        val localVariableQuery: MultiValueMap = mutableMapOf()
        val localVariableHeaders: MutableMap<String, String> = mutableMapOf()
        localVariableHeaders["Content-Type"] = "application/json"
        localVariableHeaders["Accept"] = "application/json"

        return RequestConfig(
            method = RequestMethod.PUT,
            path = "/config/{FullPath}".replace("{"+"FullPath"+"}", encodeURIComponent(fullPath.toString())),
            query = localVariableQuery,
            headers = localVariableHeaders,
            requiresAuthentication = false,
            body = localVariableBody
        )
    }

    /**
     * Create or update a datasource
     * 
     * @param name Name of the data source (max length 34)
     * @param body 
     * @return ObjectDataSource
     * @throws IllegalStateException If the request is not correctly configured
     * @throws IOException Rethrows the OkHttp execute method exception
     * @throws UnsupportedOperationException If the API returns an informational or redirection response
     * @throws ClientException If the API returns a client error response
     * @throws ServerException If the API returns a server error response
     */
    @Suppress("UNCHECKED_CAST")
    @Throws(IllegalStateException::class, IOException::class, UnsupportedOperationException::class, ClientException::class, ServerException::class)
    fun putDataSource(name: kotlin.String, body: DataSourceObjectDescription) : ObjectDataSource {
        val localVarResponse = putDataSourceWithHttpInfo(name = name, body = body)

        return when (localVarResponse.responseType) {
            ResponseType.Success -> (localVarResponse as Success<*>).data as ObjectDataSource
            ResponseType.Informational -> throw UnsupportedOperationException("Client does not support Informational responses.")
            ResponseType.Redirection -> throw UnsupportedOperationException("Client does not support Redirection responses.")
            ResponseType.ClientError -> {
                val localVarError = localVarResponse as ClientError<*>
                throw ClientException("Client error : ${localVarError.statusCode} ${localVarError.message.orEmpty()}", localVarError.statusCode, localVarResponse)
            }
            ResponseType.ServerError -> {
                val localVarError = localVarResponse as ServerError<*>
                throw ServerException("Server error : ${localVarError.statusCode} ${localVarError.message.orEmpty()} ${localVarError.body}", localVarError.statusCode, localVarResponse)
            }
        }
    }

    /**
     * Create or update a datasource
     * 
     * @param name Name of the data source (max length 34)
     * @param body 
     * @return ApiResponse<ObjectDataSource?>
     * @throws IllegalStateException If the request is not correctly configured
     * @throws IOException Rethrows the OkHttp execute method exception
     */
    @Suppress("UNCHECKED_CAST")
    @Throws(IllegalStateException::class, IOException::class)
    fun putDataSourceWithHttpInfo(name: kotlin.String, body: DataSourceObjectDescription) : ApiResponse<ObjectDataSource?> {
        val localVariableConfig = putDataSourceRequestConfig(name = name, body = body)

        return request<DataSourceObjectDescription, ObjectDataSource>(
            localVariableConfig
        )
    }

    /**
     * To obtain the request config of the operation putDataSource
     *
     * @param name Name of the data source (max length 34)
     * @param body 
     * @return RequestConfig
     */
    fun putDataSourceRequestConfig(name: kotlin.String, body: DataSourceObjectDescription) : RequestConfig<DataSourceObjectDescription> {
        val localVariableBody = body
        val localVariableQuery: MultiValueMap = mutableMapOf()
        val localVariableHeaders: MutableMap<String, String> = mutableMapOf()
        localVariableHeaders["Content-Type"] = "application/json"
        localVariableHeaders["Accept"] = "application/json"

        return RequestConfig(
            method = RequestMethod.POST,
            path = "/config/datasource/{Name}".replace("{"+"Name"+"}", encodeURIComponent(name.toString())),
            query = localVariableQuery,
            headers = localVariableHeaders,
            requiresAuthentication = false,
            body = localVariableBody
        )
    }

    /**
     * Publish scheduler action XML form for building screens in frontend
     * 
     * @param actionName Name of the action to load
     * @return RestSchedulerActionFormResponse
     * @throws IllegalStateException If the request is not correctly configured
     * @throws IOException Rethrows the OkHttp execute method exception
     * @throws UnsupportedOperationException If the API returns an informational or redirection response
     * @throws ClientException If the API returns a client error response
     * @throws ServerException If the API returns a server error response
     */
    @Suppress("UNCHECKED_CAST")
    @Throws(IllegalStateException::class, IOException::class, UnsupportedOperationException::class, ClientException::class, ServerException::class)
    fun schedulerActionFormDiscovery(actionName: kotlin.String) : RestSchedulerActionFormResponse {
        val localVarResponse = schedulerActionFormDiscoveryWithHttpInfo(actionName = actionName)

        return when (localVarResponse.responseType) {
            ResponseType.Success -> (localVarResponse as Success<*>).data as RestSchedulerActionFormResponse
            ResponseType.Informational -> throw UnsupportedOperationException("Client does not support Informational responses.")
            ResponseType.Redirection -> throw UnsupportedOperationException("Client does not support Redirection responses.")
            ResponseType.ClientError -> {
                val localVarError = localVarResponse as ClientError<*>
                throw ClientException("Client error : ${localVarError.statusCode} ${localVarError.message.orEmpty()}", localVarError.statusCode, localVarResponse)
            }
            ResponseType.ServerError -> {
                val localVarError = localVarResponse as ServerError<*>
                throw ServerException("Server error : ${localVarError.statusCode} ${localVarError.message.orEmpty()} ${localVarError.body}", localVarError.statusCode, localVarResponse)
            }
        }
    }

    /**
     * Publish scheduler action XML form for building screens in frontend
     * 
     * @param actionName Name of the action to load
     * @return ApiResponse<RestSchedulerActionFormResponse?>
     * @throws IllegalStateException If the request is not correctly configured
     * @throws IOException Rethrows the OkHttp execute method exception
     */
    @Suppress("UNCHECKED_CAST")
    @Throws(IllegalStateException::class, IOException::class)
    fun schedulerActionFormDiscoveryWithHttpInfo(actionName: kotlin.String) : ApiResponse<RestSchedulerActionFormResponse?> {
        val localVariableConfig = schedulerActionFormDiscoveryRequestConfig(actionName = actionName)

        return request<Unit, RestSchedulerActionFormResponse>(
            localVariableConfig
        )
    }

    /**
     * To obtain the request config of the operation schedulerActionFormDiscovery
     *
     * @param actionName Name of the action to load
     * @return RequestConfig
     */
    fun schedulerActionFormDiscoveryRequestConfig(actionName: kotlin.String) : RequestConfig<Unit> {
        val localVariableBody = null
        val localVariableQuery: MultiValueMap = mutableMapOf()
        val localVariableHeaders: MutableMap<String, String> = mutableMapOf()
        localVariableHeaders["Accept"] = "application/json"

        return RequestConfig(
            method = RequestMethod.GET,
            path = "/config/scheduler/actions/{ActionName}".replace("{"+"ActionName"+"}", encodeURIComponent(actionName.toString())),
            query = localVariableQuery,
            headers = localVariableHeaders,
            requiresAuthentication = false,
            body = localVariableBody
        )
    }

    /**
     * Publish scheduler registered actions
     * 
     * @return RestSchedulerActionsResponse
     * @throws IllegalStateException If the request is not correctly configured
     * @throws IOException Rethrows the OkHttp execute method exception
     * @throws UnsupportedOperationException If the API returns an informational or redirection response
     * @throws ClientException If the API returns a client error response
     * @throws ServerException If the API returns a server error response
     */
    @Suppress("UNCHECKED_CAST")
    @Throws(IllegalStateException::class, IOException::class, UnsupportedOperationException::class, ClientException::class, ServerException::class)
    fun schedulerActionsDiscovery() : RestSchedulerActionsResponse {
        val localVarResponse = schedulerActionsDiscoveryWithHttpInfo()

        return when (localVarResponse.responseType) {
            ResponseType.Success -> (localVarResponse as Success<*>).data as RestSchedulerActionsResponse
            ResponseType.Informational -> throw UnsupportedOperationException("Client does not support Informational responses.")
            ResponseType.Redirection -> throw UnsupportedOperationException("Client does not support Redirection responses.")
            ResponseType.ClientError -> {
                val localVarError = localVarResponse as ClientError<*>
                throw ClientException("Client error : ${localVarError.statusCode} ${localVarError.message.orEmpty()}", localVarError.statusCode, localVarResponse)
            }
            ResponseType.ServerError -> {
                val localVarError = localVarResponse as ServerError<*>
                throw ServerException("Server error : ${localVarError.statusCode} ${localVarError.message.orEmpty()} ${localVarError.body}", localVarError.statusCode, localVarResponse)
            }
        }
    }

    /**
     * Publish scheduler registered actions
     * 
     * @return ApiResponse<RestSchedulerActionsResponse?>
     * @throws IllegalStateException If the request is not correctly configured
     * @throws IOException Rethrows the OkHttp execute method exception
     */
    @Suppress("UNCHECKED_CAST")
    @Throws(IllegalStateException::class, IOException::class)
    fun schedulerActionsDiscoveryWithHttpInfo() : ApiResponse<RestSchedulerActionsResponse?> {
        val localVariableConfig = schedulerActionsDiscoveryRequestConfig()

        return request<Unit, RestSchedulerActionsResponse>(
            localVariableConfig
        )
    }

    /**
     * To obtain the request config of the operation schedulerActionsDiscovery
     *
     * @return RequestConfig
     */
    fun schedulerActionsDiscoveryRequestConfig() : RequestConfig<Unit> {
        val localVariableBody = null
        val localVariableQuery: MultiValueMap = mutableMapOf()
        val localVariableHeaders: MutableMap<String, String> = mutableMapOf()
        localVariableHeaders["Accept"] = "application/json"

        return RequestConfig(
            method = RequestMethod.GET,
            path = "/config/scheduler/actions",
            query = localVariableQuery,
            headers = localVariableHeaders,
            requiresAuthentication = false,
            body = localVariableBody
        )
    }


    private fun encodeURIComponent(uriComponent: kotlin.String): kotlin.String =
        HttpUrl.Builder().scheme("http").host("localhost").addPathSegment(uriComponent).build().encodedPathSegments[0]
}
